<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YMlion&#39;s Blog</title>
  
  <subtitle>写点什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ymlion.com/"/>
  <updated>2018-09-28T11:08:47.359Z</updated>
  <id>https://ymlion.com/</id>
  
  <author>
    <name>YMlion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Robust填坑</title>
    <link href="https://ymlion.com/post/robust-issues/"/>
    <id>https://ymlion.com/post/robust-issues/</id>
    <published>2018-09-28T11:04:50.000Z</published>
    <updated>2018-09-28T11:08:47.359Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/YMlion/Robust" target="_blank" rel="noopener">Robust</a>在使用过程中有很多坑，一不小心就会掉入坑中，半天爬不出来。</p><a id="more"></a><h2 id="依赖库版本"><a href="#依赖库版本" class="headerlink" title="依赖库版本"></a>依赖库版本</h2><p>坑有很多种，最容易忽略的是依赖库的版本。其中有几个比较重要的库，版本变化较大，不能轻易升级，包括<code>retrolambda</code>，<code>asm</code>，<code>javassist</code>，这几个库对于能否正常插桩、能否生成补丁包至关重要，这几个库升级后，有可能会出现比较大的问题，所以升级时要谨慎，出了问题仔细检查。当然还有最重要的一个<code>android-gradle-plugin</code>，这个可以升级，但是同样会出现一些问题，<code>robust</code>中使用的是<code>2.x</code>的版本，当升级之后会出现一些小问题，这都容易解决。目前来说，<code>retrolambda</code>升级肯定会出现问题，其他库升级出现的都是小问题，可以轻易解决。</p><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h2><p>除了版本问题，目前来说比较重要的就是<code>lambda</code>表达式，<code>as3.x</code>已经推出很长时间了，<code>lambda</code>表达式也能支持了，按理说要抛弃掉<code>2.x</code>的版本以及<code>retrolambda</code>库了，但<code>Robust</code>并没有适配<code>as3.x</code>支持的<code>lambda</code>表达式及方法引用。<code>retrolambda</code>生成的<code>lambda</code>表达式是可以支持的，但也是仅限于<code>retrolambda-3.2.0</code>及以下版本。</p><h3 id="lambda实现逻辑"><a href="#lambda实现逻辑" class="headerlink" title="lambda实现逻辑"></a><code>lambda</code>实现逻辑</h3><p><code>lambda</code>表达式具体实现逻辑，对于原生<code>java8</code>编译器、<code>as3.x</code>、<code>retrolambda</code>来说都是不同的，<code>as3.x</code>使用<code>desugar</code>对<code>.class</code>字节码进行转换，从而实现新语言功能。</p><p><img src="https://developer.android.com/studio/images/write/desugar_2x.png" alt="采用 `desugar` 字节码转换的 Java 8 语言功能支持"></p><p><code>javac</code>编译<code>lambda</code>是在运行时去解析，而<code>dalvik</code>不支持<code>invokedynamic</code>命令，所以就要将<code>.class</code>字节码编译为<code>dalvik</code>可以识别的字节码文件。<code>.class</code>文件通过<code>dex</code>优化合并为<code>.dex</code>文件时，<code>lambda</code>表达式会被进一步优化，所以<code>lambda</code>表达式处理起来稍微麻烦一些。</p><h3 id="lambda表达式编译情景"><a href="#lambda表达式编译情景" class="headerlink" title="lambda表达式编译情景"></a><code>lambda</code>表达式编译情景</h3><p><code>as3.x</code>编译<code>lambda</code>表达式时，会生成一个单独的接口实现类，而具体的实现则是放在了外部类中，生成对应的一个实现方法，接口方法中调用外部类的实现方法，至于生成的实现方法是不是静态的，可具体情况具体分析。另外，这种情况可也能会在<code>dex</code>优化中出现不同结果，有可能被内联，有可能继续保留外部的实现方法，具体看下面的几种情况。</p><p>通过对<code>lambda</code>表达式代码的表面分析，可以简单得出4种情景：是否有外部类的方法的调用和是否有外部变量的引用。</p><p>首先看最简单的一种情况，就是既没有外部方法调用也没有外部变量引用，纯粹是自己的逻辑，此时的<code>lambda</code>表达式会生成一个单独的类，并在类内生成一个静态实例，访问时就直接使用该静态实例调用其实现方法。这种情况下，和外部类没有任何关系，所以<code>dex</code>优化时会把在外部类中的实现方法逻辑重新移动到接口实现类中。</p><p>第二种是只有外部变量的引用，此时和第一种情况没有太大区别，唯一的区别就是此时的生成的<code>lambda</code>类没有静态实例，所需要的外部变量通过构造方法传递进来，在其方法实现中就会引用传递过来的成员变量，所以这种情况下也会被<code>dex</code>优化掉。</p><p>第三种就是只有外部类的方法调用，这种情况和第二种类似，因为有方法调用，所以也会保存外部类的引用，但在这种情况下，如果说调用的外部类方法不是很复杂，则有可能在最终生成的<code>.dex</code>中，会被优化掉。</p><p>第四种就是既有外部类的方法调用，也有外部变量的引用，这种情况下稍微复杂，所以<code>dex</code>优化时不会被优化掉，就还是正常调用外部类的实现方法。</p><blockquote><p>除了第一种，其他三种情况下，因为有外部类或者变量的引用，在<code>android</code>开发中很容易引起内存泄漏，尤其是<code>Context</code>、<code>View</code>等对象的外部引用，因此这种情况下慎用<code>lambda</code>表达式。</p></blockquote><h3 id="lambda表达式修复"><a href="#lambda表达式修复" class="headerlink" title="lambda表达式修复"></a><code>lambda</code>表达式修复</h3><p>由于编译时生成的字节码文件，<code>lambda</code>表达式的实现是在外部类中，而目前<code>Robust</code>查找<code>RobustModify.modify()</code>的调用是在接口实现类的方法中，因此<code>Robust</code>找不到<code>lambda</code>表达式是否有修复。<code>Robust</code>实现的是<code>retrolambda3.2.0</code>中<code>lambda</code>表达式的修复。</p><p>在<code>Robust</code>中，主要是修改<code>ReadAnnotation.scanClassForModifyMethod()</code>方法中<code>lambda</code>表达式是否需要修复的逻辑。首先定义两个变量来判断是否修复及是否有外部方法调用：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前方法是否需要修复</span></span><br><span class="line"><span class="keyword">def</span> isPatch = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 当前方法是否有外部类的方法调用</span></span><br><span class="line"><span class="keyword">def</span> isOutMethodCall = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>判断是否是<code>lambda</code>表达式就是很简单地判断了方法名是否含有<code>lambda$</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> edit(MethodCall m) <span class="keyword">throws</span> CannotCompileException &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPatch) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> callMethod = m.method</span><br><span class="line">        <span class="keyword">if</span> (Constants.LAMBDA_MODIFY == callMethod.declaringClass.name) &#123;<span class="comment">// 这种情况是retrolambda的判断</span></span><br><span class="line">            isPatch = <span class="literal">true</span></span><br><span class="line">            isAllMethodsPatch = <span class="literal">false</span></span><br><span class="line">            addPatchMethodAndModifiedClass(patchMethodSignureSet, method)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.methodName.contains(<span class="string">"lambda\$"</span>) &amp;&amp; m.methodName.endsWith(</span><br><span class="line">            callMethod.declaringClass.simpleName)) &#123;</span><br><span class="line">            callMethod.instrument(<span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">void</span> edit(MethodCall mm) <span class="keyword">throws</span> CannotCompileException &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Constants.LAMBDA_MODIFY == mm.method.declaringClass.name) &#123;</span><br><span class="line">                        isPatch = <span class="literal">true</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.method.declaringClass.name == mm.method.declaringClass.name) &#123;</span><br><span class="line">                        isOutMethodCall = <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 此处省略具体修复逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一层<code>else if</code>中是<code>lambda</code>表达式是否修复的判断，前面说过在接口实现类中，只是去调用外部类的具体实现方法，因此当前接口实现类的方法中，只有一行调用代码，所以判断这个调用代码是否含有<code>lambda$</code>以及调用的方法是否是以外部类名结尾，因为编译生成的这个外部类的实现方法是以外部类名结尾。确定当前的方法是<code>lambda</code>表达式的具体实现之后，根据每次方法调用得出<code>isPatch</code>和<code>isOutMethodCall</code>两个变量的值。后面根据这两个值去执行不同情况下的修复逻辑：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPatch) &#123;</span><br><span class="line">    <span class="keyword">def</span> newMethod</span><br><span class="line">    <span class="keyword">if</span> (isOutMethodCall) &#123;</span><br><span class="line">        <span class="comment">// 修复代码中有外部类方法调用</span></span><br><span class="line">        <span class="keyword">if</span> (hasOutParams(method, callMethod)) &#123;</span><br><span class="line">            println <span class="string">"lambda fix : 1"</span></span><br><span class="line">            <span class="comment">// 外部变量引用，此时callMethod不会在dex优化中被优化掉</span></span><br><span class="line">            newAndReplaceMethod(callMethod, method, m)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无外部变量引用，此时在dex优化时会被优化掉</span></span><br><span class="line">            <span class="comment">// 此时还有两种情况，一种是原来该方法中就有调用外部类的方法，另一种就是只在修复代码中有外部类方法调用</span></span><br><span class="line">            <span class="comment">// 但是无法判断这两种情况，因为当前的代码都是修复之后的代码编译而成</span></span><br><span class="line">            <span class="comment">//  lambda2FixList.add(method.declaringClass.name)</span></span><br><span class="line">            println <span class="string">"lambda fix : 2 "</span></span><br><span class="line">            newAndReplaceMethod(callMethod, method, m)</span><br><span class="line">        &#125;</span><br><span class="line">        newMethod = method</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 修复代码无外部类方法调用</span></span><br><span class="line">        <span class="keyword">def</span> originalClass = method.getDeclaringClass()</span><br><span class="line">        <span class="keyword">if</span> (hasOutParams(method, callMethod)) &#123;</span><br><span class="line">            println <span class="string">"lambda fix : 3"</span></span><br><span class="line">            <span class="comment">// 有外部变量引用</span></span><br><span class="line">            <span class="comment">// 复制并创建一个新的方法，并替换掉当前调用的方法</span></span><br><span class="line">            newMethod = CtNewMethod.copy(callMethod,</span><br><span class="line">                method.getName() + <span class="string">"_temp"</span>, originalClass, <span class="literal">null</span>)</span><br><span class="line">            originalClass.addMethod(newMethod)</span><br><span class="line">            m.replace(<span class="string">"&#123; $&#123;newMethod.name&#125;(\$\$); &#125;"</span>)</span><br><span class="line">            newMethod = method</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println <span class="string">"lambda fix : 4"</span></span><br><span class="line">            <span class="comment">// 仅是逻辑代码，不涉及外部方法和变量引用</span></span><br><span class="line">            <span class="comment">// 复制当前方法到原来的方法中，减少此次方法调用，直接复制会有问题，通过创建同名方法实现</span></span><br><span class="line">            originalClass.removeMethod(method)</span><br><span class="line">            newMethod = CtNewMethod.copy(callMethod,</span><br><span class="line">                method.getName(), originalClass, <span class="literal">null</span>)</span><br><span class="line">            originalClass.addMethod(newMethod)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    isAllMethodsPatch = <span class="literal">false</span></span><br><span class="line">    addPatchMethodAndModifiedClass(patchMethodSignureSet,</span><br><span class="line">        newMethod)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中解释地很清楚，总体就是根据前面<code>lambda</code>表达式编译的四种情况来实现的。这四种情况不同的实现方法也是反复摸索出来的，有替换方法、有生成新方法等等。其中抽出来的几个工具方法如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在外部类中生成新的方法，代替编译时生成的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> copyMethod 编译时生成的无插桩方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> innerMethod 内部类方法，该方法去调用编译时生成的外部类方法，该方法就是需要修复的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 在外部类中新生成的成员方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> CtMethod generateNewOutMethod(CtMethod copyMethod, CtMethod innerMethod) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Config.methodMap.get(copyMethod.longName) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Config.methodMap.remove(copyMethod.longName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> newMethod = CtNewMethod.copy(copyMethod,</span><br><span class="line">        innerMethod.getName() + <span class="string">"\$Proxy\$"</span> + Config.methodMap.get(innerMethod.longName).</span><br><span class="line">            intValue(),</span><br><span class="line">        copyMethod.declaringClass, <span class="literal">null</span>)</span><br><span class="line">    newMethod.setModifiers(Modifier.FINAL | Modifier.PUBLIC)</span><br><span class="line">    copyMethod.declaringClass.addMethod(newMethod)</span><br><span class="line">    <span class="keyword">return</span> newMethod</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在外部类中生成新的方法，代替编译时生成的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> copyMethod 编译时生成的无插桩方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> innerMethod 内部类方法，该方法去调用编译时生成的外部类方法，该方法就是需要修复的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mc 无插桩方法调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> newAndReplaceMethod(CtMethod replacedMethod, CtMethod innerMethod, MethodCall mc) &#123;</span><br><span class="line">    <span class="keyword">def</span> newMethod = generateNewOutMethod(replacedMethod, innerMethod)</span><br><span class="line">    println <span class="string">"return type is "</span> + newMethod.returnType.name</span><br><span class="line">    <span class="comment">// 不能是静态的，应该使用调用者去调用</span></span><br><span class="line">    <span class="keyword">if</span> (newMethod.returnType.name == <span class="string">"void"</span>) &#123;</span><br><span class="line">        mc.replace(<span class="string">"&#123; \$0.$&#123;newMethod.name&#125;(\$\$); &#125;"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mc.replace(<span class="string">"&#123; \$_ = \$0.$&#123;newMethod.name&#125;(\$\$); &#125;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    newMethod.declaringClass.removeMethod(replacedMethod)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否有外部变量引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> hasOutParams(CtMethod m1, CtMethod m2) &#123;</span><br><span class="line">    <span class="keyword">return</span> Descriptor.numOfParameters(m1.methodInfo.descriptor) != Descriptor.</span><br><span class="line">        numOfParameters(m2.methodInfo.descriptor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，如果有外部变量的引用，在外部类中实现的方法的参数就会比接口实现类中的方法多，因为要把外部变量传递给具体实现方法中。另外，生成新方法要考虑是否有返回值，有无返回值具体代码不同。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>除去上面提到的四种情景，还要考虑<code>lambda</code>表达式修复前后代码的差异，根据是否有外部类的方法调用和外部变量引用，要考虑的情况就复杂多了，但通过上面的分析可以看出，前后一致不需要考虑，因此只需要考虑前后不一致的情况。其中修复前就有外部类的方法调用或者外部变量的引用或者两者兼得，这种也不需要单独去处理，因为修复的代码只有自己逻辑，所以按照前面的第一种情况处理没有任何问题。最后就是修复后的代码才有外部类的方法调用或者外部变量的引用，这种情况过于复杂，涉及到构造方法变更，添加成员变量，多个方法要修复等，所以还没有比较好的方法实现。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>依赖库版本问题只要注意就能避免，<code>lambda</code>表达式的编译以及优化比较复杂，需要一点点去查看生成的<code>jar</code>文件，并反复对比，确保每一种情况都有考虑到，另外<code>javassit</code>的使用要熟悉，尤其是对于类、方法甚至其他变量的操作要清楚，才能更好去实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/YMlion/Robust&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Robust&lt;/a&gt;在使用过程中有很多坑，一不小心就会掉入坑中，半天爬不出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="热修复" scheme="https://ymlion.com/categories/Android/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="热修复" scheme="https://ymlion.com/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Robust" scheme="https://ymlion.com/tags/Robust/"/>
    
  </entry>
  
  <entry>
    <title>Android二进制xml资源文件解析</title>
    <link href="https://ymlion.com/post/res-xml-parse/"/>
    <id>https://ymlion.com/post/res-xml-parse/</id>
    <published>2018-05-09T11:25:34.000Z</published>
    <updated>2018-05-09T11:30:56.430Z</updated>
    
    <content type="html"><![CDATA[<p>在Android资源编译和打包过程中，对于<code>res</code>目录下的所有xml文件，除去<code>res/raw/</code>文件夹下的文件不被处理，其他的xml文件都需要被编译，其中<code>values</code>下的xml资源文件解析之后就保存到资源索引表<code>resources.arsc</code>里面，其他xml文件都由文本格式编译为二进制格式，另外<code>AndroidManifest.xml</code>也是被编译为二进制格式。</p><p>二进制格式相比文本格式有很大的优势，想想<code>resources.arsc</code>解析，显而易见字节处理比文本处理效率更高，有合理的结构更容易解析，同时二进制格式占用空间更小。简单来说，资源文件编译和打包过程就是为了apk更小、package和应用运行时解析资源文件更快。</p><a id="more"></a><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="xml_structure.png" alt="xml结构表"></p><p>整体看一下，看一看到有些部分和<code>resources.arsc</code>是相同的，其中两者都是以chunk组成。二进制xml文件开头是8字节的chunk头，类型是<code>RES_XML_TYPE</code>，并确定整个文件的大小；之后是资源字符串池，同样和<code>resources.arsc</code>是相同的，存放了xml文件中所用的字符串；然后是资源id数组数据块，类型是<code>RES_XML_RESOURCE_MAP_TYPE</code>，存放所有节点中有id的属性的id，像系统属性layout_width等和自定义属性，系统属性id值是固定的，如果整个文件中没有用到属性，则该数据块就不会出现；在后面就是xml文件中的节点了，由命名空间开始，经过各种节点，以及节点间的嵌套（节点开始和结束数据块交叉），最终由命名空间结束。</p><p>在资源id数据块中，如果当前的xml文件中有自定义的属性，则其对应的id是需要修改的，系统属性则不需要，所以在解析该部分时，需要判断id的第一个字节是否是<code>0x7f</code>，是则改之。</p><p>在开发时，创建的每一个xml文件都是由节点组成的，在二进制xml中，自命名空间开始才是xml的具体节点，而每个节点都是由节点头和节点类型扩展构成，下面看下节点头的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResTreeNodeHeader</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * header</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> header: ResChunkHeader</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该标签在原文件中开始出现的行号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> lineNumber: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该标签的注释在字符串资源池中的位置，一般该值不会出现在资源池中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> comment: <span class="built_in">Int</span> = <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点头16字节，包括chunk头和自定义的两个变量，其中自定义的行号和注释索引目前看来没有什么用，当然如果是反编译的话行号还是有用的。下面从命名空间开始，来看下每种节点的具体结构。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在需要编译为二进制的xml文件中，除了自定义xml文件有可能没有命名空间，其他的所有文件都存在命名空间。命名空间有可能有多个，像在有自定义属性的xml文件中，会需要加一个命名空间，xml文件节点都是嵌套的，命名空间是第一个节点，同样也是最后一个节点，前后呼应，开始和结束节点结构完全相同，只是chunk类型不同。</p><p>命名空间开始节点类型是<code>RES_XML_START_NAMESPACE_TYPE</code>，结束类型是<code>RES_XML_END_NAMESPACE_TYPE</code>，除去节点头，后面是命名空间扩展，其定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">NamespaceExt</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * namespace前缀在字符串池中的位置, like android in xmlns:android="the URI"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> prefix: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * index of namespace' URI in string pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> uri: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们编写xml文件时，命名空间都是由两部分组成：前缀和URI，下面以一个实际的布局文件来说明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/message"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">"@dimen/activity_horizontal_margin"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"@dimen/activity_vertical_margin"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:text</span>=<span class="string">"@string/title_home"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.design.widget.BottomNavigationView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/navigation"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginEnd</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"?android:attr/windowBackground"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:menu</span>=<span class="string">"@menu/navigation"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般情况下编写的xml文件，只有一个命名空间就是上面代码中的第一个，但有时也会用到其他的命名空间，在上面的布局文件中其他两个比较常用的也都有了。</p><ul><li><code>android</code>：系统属性的前缀，表明当前属性是系统定义的，有固定的id；</li><li><code>app</code>：自定义属性的前缀，像<code>app:menu</code>，当然这个前缀完全可以换个字符串，自定义属性id的第一个字节是<code>0x7f</code>；</li><li><code>tools</code>：简单来说就是在设计及编译阶段，提供一些特定功能，不影响实际打包及应用运行时的功能，像上面的<code>tools:text</code>可以在预览时显示文字，但实际运行时却没有；<code>tools:context</code>表明当前布局文件和哪个activity关联，在预览及编写布局时会提供帮助。当然还有很多其他属性，在<a href="https://developer.android.com/studio/write/tool-attributes" target="_blank" rel="noopener">官方文档</a>中有详细介绍。</li></ul><h2 id="元素节点"><a href="#元素节点" class="headerlink" title="元素节点"></a>元素节点</h2><p>命名空间之后就是具体的元素节点了，元素节点开始类型是<code>RES_XML_START_ELEMENT_TYPE</code>，每个元素都有多个属性，就像上面布局文件的每一个<code>View</code>，所以元素节点有节点头、属性扩展和属性数组构成，属性扩展定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">AttrExt</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该节点的命名空间在字符串池中的索引，一般没有, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> ns = <span class="number">-1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该节点的名称在字符串池中的索引, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes, 该node的属性偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> attributeStart = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes，该node的每个属性大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> attributeSize = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes，该节点属性数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> attributeCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes，id属性索引，从1开始，0表示没有，一般为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> idIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes, class属性索引，从1开始，0表示没有，一般为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> classIndex = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes, style属性索引，从1开始，0表示没有，一般为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> styleIndex = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性扩展共20字节，主要确定了当前元素的名称在字符串池中的索引以及属性的数量，其他变量暂时没有什么作用，基本都是固定的，像属性偏移位置为20，属性大小为20等。后面紧接着是属性数组，大小就是属性扩展中定义的数量，属性具体定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Attribute</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该属性的命名空间在字符串池中的索引，一般没有, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> ns = <span class="number">-1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该属性的名称在字符串池中的索引, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该属性的值在字符串池中的索引, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> rawValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析之后的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> typedValue: ResValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResValue</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类字节数, 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0, 1 byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> res0 = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源数据类型, 1 byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> dataType = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源值或资源id，值或值在字符串池中的索引, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性共20字节，定义了当前属性名称在字符串池中的索引，具体的值一般在<code>ResValue</code>中确定，<code>ResValue</code>和<code>resources.arsc</code>中资源项值定义时相同的，所以要修改的地方也是同样的，即<code>ResValue.data</code>。</p><p>无论元素是否有嵌套，总是会有与前面开始相呼应的结束数据块，在元素节点结束时，chunk类型是<code>RES_XML_END_ELEMENT_TYPE</code>，该数据块由节点头和元素结束扩展构成，具体定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndElementExt</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该节点的命名空间在字符串池中的索引，一般没有, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> ns = <span class="number">-1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该节点的名称在字符串池中的索引, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8个字节，很简单，主要定义了结束元素的名称在字符串池中的索引。到此为止，在一开始的表中显示的结构都解析完了，但实际上还有一种元素节点类型没有解析，当然这种类型也很少出现，就是类似下面这种：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span>hello world<span class="tag">&lt;<span class="name">item</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这种没有属性，只有一个值的元素节点，在<code>values</code>文件夹下的xml中很常见，但<code>values</code>下的xml并不会被编译为二进制文件，所以自定义的xml中有可能有这种节点。而上面的各种数据结构都没有定义，这种元素节点有个专门的数据结构代替属性数组部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">CDataExt</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * the raw data index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = <span class="number">-1</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析后的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> typedData: ResValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种节点属于<code>CData</code>节点，12字节，同样用一个<code>ResValue</code>来表示具体的数据，所以如果是这种节点，还要修改<code>ResValue.data</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>二进制xml文件结构相对于<code>resources.arsc</code>简单多了，尤其是个节点都是前后对应的，整体解析过程如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> xmlHeader = ResChunkHeader(mInput).takeIf &#123;</span><br><span class="line">        it.type == ResChunkHeader.RES_XML_TYPE</span><br><span class="line">    &#125;?.apply &#123; println(<span class="keyword">this</span>) &#125;</span><br><span class="line">    checkNotNull(xmlHeader)</span><br><span class="line">    <span class="comment">// 字符串池，xml中用的的字符串</span></span><br><span class="line">    parseStringPool(stringPool)</span><br><span class="line">    <span class="keyword">var</span> chunkHeader = ResChunkHeader(mInput)</span><br><span class="line">    <span class="keyword">if</span> (chunkHeader.type == ResChunkHeader.RES_XML_RESOURCE_MAP_TYPE) &#123;<span class="comment">// 该部分并不是必须存在的</span></span><br><span class="line">        <span class="comment">// 资源id，属于xml中具有资源id的属性，像系统属性layout_width等和自定义属性，系统属性id值固定</span></span><br><span class="line">        <span class="comment">// 每个id有4字节</span></span><br><span class="line">        mInput.skipBytes(chunkHeader.size - chunkHeader.headSize)</span><br><span class="line">        chunkHeader = ResChunkHeader(mInput)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> nodeHeader = ResTreeNodeHeader(mInput, chunkHeader)</span><br><span class="line">    <span class="comment">// 开始解析namespace，该部分是前后对应的，start with this namespace, then end with this too.</span></span><br><span class="line">    <span class="keyword">while</span> (nodeHeader.header.type == ResChunkHeader.RES_XML_START_NAMESPACE_TYPE) &#123;</span><br><span class="line">        <span class="keyword">val</span> nsExt = NamespaceExt(mInput)</span><br><span class="line">        <span class="comment">// namespace有可能并不止一个</span></span><br><span class="line">        nodeHeader = ResTreeNodeHeader(mInput)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始解析具体node，同样每个node都是前后对应的，有开始就有结束，并且node里面可以包含node</span></span><br><span class="line">    <span class="keyword">while</span> (nodeHeader.header.type == ResChunkHeader.RES_XML_START_ELEMENT_TYPE) &#123;</span><br><span class="line">        <span class="keyword">val</span> attrExt = AttrExt(mInput)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until attrExt.attributeCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> attr = Attribute(mInput)</span><br><span class="line">        &#125;</span><br><span class="line">        nodeHeader = ResTreeNodeHeader(mInput)</span><br><span class="line">        <span class="comment">// 在没有attribute时，如果该node仅仅是一项数据，则是CDATA类型</span></span><br><span class="line">        <span class="comment">// 在android资源打包过程中，values类型的xml文件是不会被编译为二进制xml文件的，其他类型的xml文件没有这</span></span><br><span class="line">        <span class="comment">// 种格式的节点，所以正常情况下是不会有这种类型的数据，但自定义的xml文件就有可能包含了。</span></span><br><span class="line">        <span class="keyword">if</span> (nodeHeader.header.type == ResChunkHeader.RES_XML_CDATA_TYPE) &#123;</span><br><span class="line">            <span class="keyword">val</span> cDataExt = CDataExt(mInput)</span><br><span class="line">            nodeHeader = ResTreeNodeHeader(mInput)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// node结束有可能并不止一个</span></span><br><span class="line">        <span class="keyword">while</span> (nodeHeader.header.type == ResChunkHeader.RES_XML_END_ELEMENT_TYPE) &#123;</span><br><span class="line">            <span class="keyword">val</span> endElementExt = EndElementExt(mInput)</span><br><span class="line">            <span class="keyword">if</span> (mInput.filePointer == xmlHeader!!.size.toLong()) &#123;</span><br><span class="line">                mInput.close()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            nodeHeader = ResTreeNodeHeader(mInput)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析与前面对应的namespace结束</span></span><br><span class="line">    <span class="keyword">while</span> (nodeHeader.header.type == ResChunkHeader.RES_XML_END_NAMESPACE_TYPE) &#123;</span><br><span class="line">        <span class="keyword">val</span> nsExt = NamespaceExt(mInput)</span><br><span class="line">        <span class="keyword">if</span> (mInput.filePointer == xmlHeader!!.size.toLong()) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// namespace有可能并不止一个</span></span><br><span class="line">        nodeHeader = ResTreeNodeHeader(mInput)</span><br><span class="line">    &#125;</span><br><span class="line">    mInput.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改package id的地方有3个：资源id数据块中的每一个自定义id、元素节点属性值、<code>CData</code>节点值。</p><p>通过<a href="https://ymlion.com/post/resources-arsc-parse/">上一篇</a>和这一篇，AAPT工具生成的二进制文件<code>resources.arsc</code>、<code>AndroidManifest.xml</code>和xml资源文件就都能修改package id了。AAPT工具还生成了另外两个文本文件<code>R.txt</code>和<code>R.java</code>，这两个就按行改就行了，不需要任何解析。到此，宿主和插件的资源冲突及资源共享问题基本算是可以解决了，具体实现代码都在<a href="https://github.com/YMlion/android-res-parser" target="_blank" rel="noopener">android-res-parser库</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android资源编译和打包过程中，对于&lt;code&gt;res&lt;/code&gt;目录下的所有xml文件，除去&lt;code&gt;res/raw/&lt;/code&gt;文件夹下的文件不被处理，其他的xml文件都需要被编译，其中&lt;code&gt;values&lt;/code&gt;下的xml资源文件解析之后就保存到资源索引表&lt;code&gt;resources.arsc&lt;/code&gt;里面，其他xml文件都由文本格式编译为二进制格式，另外&lt;code&gt;AndroidManifest.xml&lt;/code&gt;也是被编译为二进制格式。&lt;/p&gt;
&lt;p&gt;二进制格式相比文本格式有很大的优势，想想&lt;code&gt;resources.arsc&lt;/code&gt;解析，显而易见字节处理比文本处理效率更高，有合理的结构更容易解析，同时二进制格式占用空间更小。简单来说，资源文件编译和打包过程就是为了apk更小、package和应用运行时解析资源文件更快。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="资源打包" scheme="https://ymlion.com/tags/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>resources.arsc解析</title>
    <link href="https://ymlion.com/post/resources-arsc-parse/"/>
    <id>https://ymlion.com/post/resources-arsc-parse/</id>
    <published>2018-05-08T08:31:59.000Z</published>
    <updated>2018-05-09T11:29:58.819Z</updated>
    
    <content type="html"><![CDATA[<p>Android插件化实现过程中，同一进程下插件和宿主资源共享和冲突问题像一座山挡住了路，无法避开。在Android中，所有资源都是通过资源id进行引用，因此，要越过这座山，简单可行的解决方法就是修改资源id。资源id是一个<code>int</code>值，四字节，格式是0xPPTTEEEE：</p><ul><li>PP：package id，第一个字节，范围在[0x01, 0x7f]，系统应用为0x01，第三方应用为0x7f；</li><li>TT：type id，第二个字节，一般有十多个类型，像layout、id、drawable、anim等等；</li><li>EEEE：资源在同类型下的索引。</li></ul><a id="more"></a><p>通过对资源id格式的了解，修改资源id最简单的方法是修改package id，不同的插件包设置不同的package id，就很容易实现资源共享和解决资源冲突。通过分析<a href="https://blog.csdn.net/luoshengyang/article/details/8744683" target="_blank" rel="noopener">资源编译和打包过程</a>，package id的修改方法也就很明确了，主要有三种：</p><ul><li>修改<code>aapt</code>工具源码，在获取package id时进行替换；</li><li>通过<code>public.xml</code>固定资源id；</li><li>修改<code>aapt</code>打包生成的资源相关文件，包括<code>resources.arsc</code>、二进制xml、R.java文件等。</li></ul><p>相对来说，第一种和第二种实现比较简单，但更不可控，有很多变数在里面，这里就不讨论前两种的实现，主要讨论第三种的实现。在最终的生成文件中，其中类似R.java等文本文件修改最为简单，读一行改一行就可以了，而二进制文件则需要分析其格式，找到对应的资源id位置并修改之。本篇就先来分析资源索引表<code>resources.arsc</code>。</p><h2 id="resources-arsc文件结构概览"><a href="#resources-arsc文件结构概览" class="headerlink" title="resources.arsc文件结构概览"></a>resources.arsc文件结构概览</h2><p>在网上一直传播着一张图，也是比较详细刻画<code>resources.arsc</code>结构的一张图，先来看下这张图：</p><p><img src="resources_arsc_detail.png" alt="resouces.arsc详细结构图"></p><p>整体可以看出，<code>arsc</code>文件是由一个一个的chunk(块)组成，整体是一个table chunk，该表由两大部分组成：</p><ul><li>全局字符串池</li><li>package chunk：一般情况下每个apk只有一个package，每个package包含了资源类型及每一个资源项</li></ul><p>该图将每一chunk的构成甚至每一字节都比较详细列了出来，对于整体结构认识有很大帮助，但也可以看出，在package部分，尤其是在<code>Type Spec</code>及其之后，就有点乱了，对于<code>Type Spec</code>及<code>Type Type</code>之间的关系没有搞清楚。所以，为了更正上面这张图的结构错误，我重新做了一张表，除去了详细信息，主要表现整体结构及每个chunk之间的数量及关系：</p><p><img src="resources_arsc.png" alt="resouces.arsc结构图"></p><p>通过这张表去了解package数据块中不同数据块的关系，尤其是<code>type spec</code>和<code>type type</code>之间的关系通过第一张图去了解具体数据块的内容，两者相辅相成就把整个<code>arsc</code>文件结构和内容都表现出来了。</p><h2 id="chunk-header"><a href="#chunk-header" class="headerlink" title="chunk header"></a>chunk header</h2><p>每一个chunk的前8个字节都是一样的，即chunk头，表明chunk类型、头大小及chunk大小，chunk头的结构定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResChunkHeader</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_NULL_TYPE = <span class="number">0x0000</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_STRING_POOL_TYPE = <span class="number">0x0001</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_TABLE_TYPE = <span class="number">0x0002</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_XML_TYPE = <span class="number">0x0003</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Chunk types in RES_XML_TYPE</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_FIRST_CHUNK_TYPE    = <span class="number">0x0100</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_START_NAMESPACE_TYPE= <span class="number">0x0100</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_END_NAMESPACE_TYPE  = <span class="number">0x0101</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_START_ELEMENT_TYPE  = <span class="number">0x0102</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_END_ELEMENT_TYPE    = <span class="number">0x0103</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_CDATA_TYPE          = <span class="number">0x0104</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_LAST_CHUNK_TYPE     = <span class="number">0x017f</span></span><br><span class="line">        <span class="comment">// This contains a uint32_t array mapping strings in the string</span></span><br><span class="line">        <span class="comment">// pool back to resource identifiers.  It is optional.</span></span><br><span class="line">        const <span class="keyword">val</span> RES_XML_RESOURCE_MAP_TYPE   = <span class="number">0x0180</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Chunk types in RES_TABLE_TYPE</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_TABLE_PACKAGE_TYPE = <span class="number">0x0200</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_TABLE_TYPE_TYPE = <span class="number">0x0201</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_TABLE_TYPE_SPEC_TYPE = <span class="number">0x0202</span></span><br><span class="line">        <span class="keyword">public</span> const <span class="keyword">val</span> RES_TABLE_LIBRARY_TYPE = <span class="number">0x0203</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk type, 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> type = RES_NULL_TYPE</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk head size, 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> headSize = <span class="number">8</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk size = head size + data size, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据块类型有很多，主要分为通用性、table类型（即<code>arsc</code>文件中出现的类型）、xml类（即xml文件中用到的类型）。<code>resouces.arsc</code>是一个table chunk（资源索引表），chunk类型为<code>RES_TABLE_TYPE</code>，表头除去chunk头，还有4个字节用于表示package数量，正常情况下是1，就不单独列代码了。</p><h2 id="全局资源字符串池"><a href="#全局资源字符串池" class="headerlink" title="全局资源字符串池"></a>全局资源字符串池</h2><p>紧接着表头之后，就是全局资源字符串池，类型为<code>RES_STRING_POOL_TYPE</code>，该数据块存放所有资源中用到的字符串值。首先是头部，共28字节，定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 28 bytes，主要描述package中定义的字符串值和字符串样式数量和位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YMlion on 2018/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResStringPoolHeader</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk head, 8 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> header: ResChunkHeader</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * strings count, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> stringCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * style count, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> styleCount: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string 编码格式, 默认UTF-8, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> flags: <span class="built_in">Int</span> = <span class="number">0x100</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * strings start offset, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> stringsStart: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * styles start offset, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> stylesStart: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是字符串和样式4字节偏移数组，数量就是<code>ResStringPoolHeader</code>中获取的，记录了每个字符串和样式相对于头部的偏移位置。偏移数组解之后，就是字符串和样式了，先看字符串的结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPoolString</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string length, 1 byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string content, length bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> content: String</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 byte or 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> endMark = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度并不固定，除了本身内容不固定，而且不同的编码格式导致字符串长度不固定。其中<code>ResStringPoolHeader.flags</code>变量来确定当前字符串池中的字符串时以<code>UTF-8</code>还是<code>UTF-16</code>来编码的，<code>flags</code>当为0x100，即<code>UTF-8</code>标志位为1，当为0时则是<code>UTF-16</code>，两者主要区别为：</p><ul><li>UTF-8：每个字符占1个字节，<code>endMark</code>为一个字节，整体前两个字节中的第二个字节表示字符串实际长度；</li><li>UTF-16：每个字符占2个字节，第二个字节为0x00，<code>endMark</code>也是2字节，整体前两个字节表示字符串实际长度，而字符串的所占字节数需要*2。</li></ul><blockquote><p>当编码方式为<code>UTF-8</code>时，前两个字节的第二个字节是字符串长度，但一个字节最大是127，所以当字符串长度大于127时，会多出一个字节，共两个字节表示，实际计算方法是<code>length = b2 or ((b1 and 0x7f) shl 8)</code>。同样，虽然目前没有发现第一个字节有什么用，但其和第二个字节的变化时相同的，大于127时也会多加一个字节。大部分情况下两个字节是相同的，只有少数特殊字符，第一个字节不对，所以整体以第二个字节为准。</p></blockquote><p>把所有字符串解析完之后，需要进行4字节对齐，对齐之后就是字符串样式，其结构如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPoolStyle</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该值是字符串在字符串池中的索引，找到后即对应的样式名称，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串中应用该样式的起始位置，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> firstChar = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串中应用该样式的终止位置，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> lastChar = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> endMark = <span class="number">0xffffffff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据该结构的定义，字符串样式共16字节，样式的名称同样保存在字符串池中，并能够得到该样式应用的起止位置，因此可以得出一个字符串可以对应于多个样式，如斜体、加粗等等，每个样式最后以<code>0xffffffff</code>结尾。</p><p>解析完所有字符串样式之后，会以8字节<code>0xff</code>结尾，但字符串池中的<code>styleCount</code>为0，则不会出现。整个字符串池解析完之后，还需要核对一下当前位置是不是整个chunk的结尾，有可能有4个字节的<code>0x00</code>用来作为整个chunk的结尾。</p><h2 id="package-chunk"><a href="#package-chunk" class="headerlink" title="package chunk"></a>package chunk</h2><p>一个应用的所有资源都要在包数据块中有所体现，尤其像同一种资源不同的配置，所以包数据块整体比较复杂。先来看下头部定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResPackageHeader</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk header, 8 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> header: ResChunkHeader</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * package id, 应用默认为0x7F，系统应用为0x01，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0x7f</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * package name，256 bytes, 除去字符以0x00填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源类型字符串池相对于头部的偏移，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> typeStrings = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源类型种数，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> lastPublicType = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源名称字符串池相对于头部偏移，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> keyStrings = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源名称数量，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> lastPublicKey = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包数据块类型为<code>RES_TABLE_PACKAGE_TYPE</code>，通过头部的定义，有三点需要说明：</p><ul><li>package id，即资源id的第一个字节，虽然该变量占据4字节，但是只有第一个字节是有效的，所以这个位置是修改package id的第一个位置；</li><li>头部中用256个字节来确定包名，也可以发现包名长度不能超过256个字符；</li><li>资源类型数量确定了整个包有多少资源类型，同时确定了后面有多少资源类型规范。</li></ul><p>紧接着是资源类型字符串池和资源名称字符串池，这两个数据块和全局资源字符串池结构是相同的，其结构就不再赘述。其中资源类型字符串池保存了包中所有的资源类型，一般十多种；而资源名称字符串池保存了在xml中定义的每个名称(key)，而值(value)如果是字符串则存放在全局资源字符串池中，非字符串则在后面的entry中保存。</p><h2 id="Type-Spec-chunk"><a href="#Type-Spec-chunk" class="headerlink" title="Type Spec chunk"></a>Type Spec chunk</h2><p>资源类型规范数据块用于描述每种类型的资源的配置情况，不同类型甚至不同资源都有可能有不同的配置，每一种类型对应于一种规范，同类型不同配置则在同一规范下有所不同。先看下chunk头定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResTypeSpecHeader</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk header, 8 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> header: ResChunkHeader? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源类型id，1 byte, start with 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同类型资源数量, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> entryCount = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该数据块类型是<code>RES_TABLE_TYPE_SPEC_TYPE</code>，16字节；头部定义了资源类型id，即资源id的第二个字节，同样是4个字节，后三个字节为保留位。</p><p>数据块头之后是4字节为单位的资源项配置数组，在数据块头中的<code>entryCount</code>定义了当前类型有多少资源项，即数组大小，每一项都有一个配置，不同配置对应于不同的标志位。</p><h2 id="类型资源数据块"><a href="#类型资源数据块" class="headerlink" title="类型资源数据块"></a>类型资源数据块</h2><p>同一类型的资源有可能有多种配置，像不同尺寸的drawable，每种配置下的资源项数量也不一定相同，因此该数据块用于描述资源配置信息。首先是头部定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResTypeHeader</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * chunk header, 8 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> header: ResChunkHeader</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * type id, 1 byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型资源数量，4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> entryCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * offset, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> entriesStart = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该部分配置信息和android版本相关，大小有可能不同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ResTableConfig</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该部分大小，默认大小52字节，4 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> size = <span class="number">0x34</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 移动设备国家代码，2 bytes，中国460</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> mcc = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 移动网络代码，2 bytes，移动00，和mcc确定网络运营商</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> mnc = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4 bytes，前两个字节为语言，后两个为国家</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> locale = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方向, 1 byte</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> orientation = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 byte</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> touchscreen = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> density = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4 bytes, 4字节分别对应不同属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> input = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> screenWidth = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> screenHeight = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> sdkVersion = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes, always 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> minorVersion = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4 bytes, 1 + 1 + 2 bytes对应不同属性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> screenConfig = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> screenWidthDp = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> screenHeightDp = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> localeScript = CharArray(<span class="number">4</span>)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 8 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> localeVariant = CharArray(<span class="number">8</span>)</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> screenConfig2 = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该数据块类型是<code>RES_TABLE_TYPE_TYPE</code>，其中<code>id</code>和<code>entryCount</code>和类型规范中是相同的，<code>entryCount</code>并不是当前配置的资源项数量，除去前20个字节，后面就是资源配置数据结构，用于描述当前的类型资源配置，该部分大小和android版本有关，具体配置内容可以看上面的代码。</p><p>数据头之后就是4字节资源项偏移数组，如果该资源项在当前的配置中，则其偏移量非负，否则为<code>0xFFFFFFFF</code>，即-1，通过计算非负偏移量个数，可以得到当前配置下的资源项数量。</p><h2 id="资源项"><a href="#资源项" class="headerlink" title="资源项"></a>资源项</h2><p>资源项包括资源名称和资源值，先来看下其定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ResTableEntry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * flags为1时，该资源为bag资源，该entry为map entry，即多了8字节，并且在该entry之后，会有map数组；</span></span><br><span class="line"><span class="comment">     * 否则为非bag资源，在该entry之后，为value。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; 2 bytes &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> flags = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源名称在资源名称字符串池中的索引，4字节</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> key = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ResMapEntry</span></span>() : ResTableEntry() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 父节点，4字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> parent = <span class="number">0</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * bag资源可取值数量，4字节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ResTableMap</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 资源id, 4 bytes</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">var</span> name = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> value: ResValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ResValue</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类字节数, 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0, 1 byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> res0 = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源数据类型, 1 byte</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> dataType = <span class="number">0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源值或资源id，值或值在字符串池中的索引, 4 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及多个数据结构，资源项的名字用<code>ResTableEntry.key</code>表示，该值是在<strong>资源名称字符串池</strong>中的索引；其中<code>flags</code>来区别资源项是否是bag资源，bag资源因为多一层定义，所以为了定义该资源值，则需要使用<code>ResMapEntry</code>来定义，确定bag取值数量及其父亲id，若无则为0。</p><blockquote><p>根据资源值不同，分为bag资源和非bag资源，bag资源通俗来说是引用，并不是实际的值，在属性定义时，有时会定义该属性的值有几个选项，像<code>layout_width</code>，定义其值可以是<code>match_parent</code>、<code>wrap_content</code>等，类似枚举，这种资源就是bag资源；非bag资源的值就是实际的值。</p></blockquote><p>bag资源取值有多个，所以紧跟<code>ResMapEntry</code>之后是<code>ResMapEntry.count</code>个<code>ResTableMap</code>的数组，<code>ResTableMap.name</code>是当前bag的资源id。无论是bag资源还是非bag资源，资源值的结构都是<code>ResValue</code>，其中<code>ResValue.dataType</code>有多种，像<code>color</code>、<code>string</code>等，具体取值如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// Contains no data.  </span></span><br><span class="line">    TYPE_NULL = <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// The 'data' holds a ResTable_ref, a reference to another resource  </span></span><br><span class="line">    <span class="comment">// table entry.  </span></span><br><span class="line">    TYPE_REFERENCE = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">// The 'data' holds an attribute resource identifier.  </span></span><br><span class="line">    TYPE_ATTRIBUTE = <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">// The 'data' holds an index into the containing resource table's  </span></span><br><span class="line">    <span class="comment">// global value string pool.  </span></span><br><span class="line">    TYPE_STRING = <span class="number">0x03</span>,</span><br><span class="line">    <span class="comment">// The 'data' holds a single-precision floating point number.  </span></span><br><span class="line">    TYPE_FLOAT = <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">// The 'data' holds a complex number encoding a dimension value,  </span></span><br><span class="line">    <span class="comment">// such as "100in".  </span></span><br><span class="line">    TYPE_DIMENSION = <span class="number">0x05</span>,</span><br><span class="line">    <span class="comment">// The 'data' holds a complex number encoding a fraction of a  </span></span><br><span class="line">    <span class="comment">// container.  </span></span><br><span class="line">    TYPE_FRACTION = <span class="number">0x06</span>,</span><br><span class="line">    <span class="comment">// Beginning of integer flavors...  </span></span><br><span class="line">    TYPE_FIRST_INT = <span class="number">0x10</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form n..n.  </span></span><br><span class="line">    TYPE_INT_DEC = <span class="number">0x10</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form 0xn..n.  </span></span><br><span class="line">    TYPE_INT_HEX = <span class="number">0x11</span>,</span><br><span class="line">    <span class="comment">// The 'data' is either 0 or 1, for input "false" or "true" respectively.  </span></span><br><span class="line">    TYPE_INT_BOOLEAN = <span class="number">0x12</span>,</span><br><span class="line">    <span class="comment">// Beginning of color integer flavors...  </span></span><br><span class="line">    TYPE_FIRST_COLOR_INT = <span class="number">0x1c</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form #aarrggbb.  </span></span><br><span class="line">    TYPE_INT_COLOR_ARGB8 = <span class="number">0x1c</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form #rrggbb.  </span></span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form #aarrggbb.  </span></span><br><span class="line">    TYPE_INT_COLOR_ARGB8 = <span class="number">0x1c</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form #rrggbb.  </span></span><br><span class="line">    TYPE_INT_COLOR_RGB8 = <span class="number">0x1d</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form #argb.  </span></span><br><span class="line">    TYPE_INT_COLOR_ARGB4 = <span class="number">0x1e</span>,</span><br><span class="line">    <span class="comment">// The 'data' is a raw integer value of the form #rgb.  </span></span><br><span class="line">    TYPE_INT_COLOR_RGB4 = <span class="number">0x1f</span>,</span><br><span class="line">    <span class="comment">// ...end of integer flavors.  </span></span><br><span class="line">    TYPE_LAST_COLOR_INT = <span class="number">0x1f</span>,</span><br><span class="line">    <span class="comment">// ...end of integer flavors.  </span></span><br><span class="line">    TYPE_LAST_INT = <span class="number">0x1f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>资源数据类型不同取值会决定资源值<code>ResValue.data</code>是何种形式，如果是字符串，则<code>data</code>就是全局资源字符串池中的索引，如果是数值则就是实际值，如果是<code>color</code>并属于bag资源则是资源id。</p><p>资源项这部分涉及到资源id的有3个地方，分别是<code>ResMapEntry.parent</code>、<code>ResTableMap.name</code>、<code>ResValue.data</code>，当然以上3处的实际值并不一定是资源id，只是有可能是，所以在修改package id的时候，先判断一下该资源id的第一个字节是不是<code>0x7f</code>，如果是则修改之。</p><h2 id="解析小结"><a href="#解析小结" class="headerlink" title="解析小结"></a>解析小结</h2><p>分析完资源项的结构，整个资源索引表的详细结构就都分析完了，再次捋顺一下包数据块的结构逻辑：每个package包含多个资源类型，每个资源类型对应一种类型规范，每个类型规范中有一种或多种资源配置，每种配置下都有至少一个资源项，所有配置下的资源项数相加的和就是类型规范中定义的资源项数。下面看下具体解析代码逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parse</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tableHeader = parseTableHeader()</span><br><span class="line">    <span class="comment">// 解析全局字符串资源值，字符串池存放所有资源的值，并且该值为字符串</span></span><br><span class="line">    <span class="comment">// 像所有的xml文件名、图片资源名、xml中定义的字符串、系统定义的字符串</span></span><br><span class="line">    parseStringPool()</span><br><span class="line">    <span class="keyword">val</span> packageHeader = parsePackageHeader()</span><br><span class="line">    <span class="comment">// package chunk后面是资源类型字符串池和资源名称字符串池</span></span><br><span class="line">    <span class="comment">// 这两部分的结构和和前面的字符串池结构相同，只不过字符串样式数量为0</span></span><br><span class="line">    <span class="comment">// 先解析资源类型字符串池，资源类型有限，一般十多种</span></span><br><span class="line">    parseStringPool()</span><br><span class="line">    <span class="comment">// 解析资源名称字符串池，资源定义中的属性(key)字符串存放在这里，值(value)有一部分存放在全局字符串池中，非字符串则存放在后面的entry中</span></span><br><span class="line">    parseStringPool()</span><br><span class="line">    <span class="comment">// 后面同样属于package部分，根据资源类型数量，分别解析，直到全部解析完</span></span><br><span class="line">    <span class="keyword">var</span> resHeader = ResChunkHeader(mInput)</span><br><span class="line">    <span class="comment">// 有多少资源类型，后面就有多少 type spec</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until packageHeader.lastPublicType) &#123;</span><br><span class="line">        <span class="keyword">val</span> specHeader = ResTypeSpecHeader(mInput, resHeader)</span><br><span class="line">        <span class="comment">// spec 资源数组</span></span><br><span class="line">        mInput.skipBytes(<span class="number">4</span> * specHeader.entryCount)</span><br><span class="line">        resHeader = ResChunkHeader(mInput)</span><br><span class="line">        <span class="keyword">while</span> (resHeader.type == <span class="number">0x0201</span>) &#123;<span class="comment">// 每种类型的资源可以有多种配置</span></span><br><span class="line">            <span class="keyword">val</span> typeHeader = ResTypeHeader(mInput, resHeader)</span><br><span class="line">            println(typeHeader)</span><br><span class="line">            <span class="keyword">val</span> chunkEnd = mInput.filePointer + typeHeader.header.size - typeHeader.header.headSize</span><br><span class="line">            <span class="comment">// entry偏移数组</span></span><br><span class="line">            mInput.skipBytes(typeHeader.entryCount * <span class="number">4</span>)</span><br><span class="line">            <span class="comment">// 读取资源项</span></span><br><span class="line">            <span class="comment">// 同一类型的资源可能有不同的配置，当前配置下不一定有所有的资源，只有是该配置的资源才会出现</span></span><br><span class="line">            <span class="comment">// 因此entry的数量是当前配置的资源数量，并不一定是全部，具体有多少个在entry偏移数组中有所体现</span></span><br><span class="line">            <span class="comment">// entry数组中偏移值为正的则在当前配置下</span></span><br><span class="line">            <span class="keyword">while</span> (mInput.filePointer &lt; chunkEnd) &#123;<span class="comment">// 根据整个type块的大小来确定是否读取完</span></span><br><span class="line">                ResMapEntry(mInput)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tableHeader.header.size == mInput.filePointer.toInt()) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            resHeader = ResChunkHeader(mInput)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInput.close()</span><br><span class="line">    <span class="keyword">return</span> available</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析逻辑很清晰，那么修改package id也就很简单了，找到对应的位置修改就可以了，就不再展示代码了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>资源索引表是所有二进制资源文件中最复杂的一个，主要是在package数据块里面稍显复杂的逻辑关系，这也是理清整个结构的关键点。另外资源索引表同样加入了第三方库中的资源项，这也同样加大了复杂度。</p><p>插件化时，修改的是插件的资源索引表，为了资源冲突和共享，所以更深一点思考，除了修改资源id，还需要把宿主和插件相同的资源在插件中去除，这样就更好了。换一个角度思考，资源索引表中有所有资源文件的字符串，因此就资源混淆角度来说，替换资源文件对应的字符串为混淆后的字符串，并修改每个资源文件的路径和名称，重新打包则就实现了资源混淆，这也是<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">AndResGuard</a>的基本原理。</p><p><a href="https://ymlion.com/post/res-xml-parse/">下一篇</a>分析二进制xml文件的结构并修改资源id，具体实现代码都在<a href="https://github.com/YMlion/android-res-parser" target="_blank" rel="noopener">android-res-parser库</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android插件化实现过程中，同一进程下插件和宿主资源共享和冲突问题像一座山挡住了路，无法避开。在Android中，所有资源都是通过资源id进行引用，因此，要越过这座山，简单可行的解决方法就是修改资源id。资源id是一个&lt;code&gt;int&lt;/code&gt;值，四字节，格式是0xPPTTEEEE：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PP：package id，第一个字节，范围在[0x01, 0x7f]，系统应用为0x01，第三方应用为0x7f；&lt;/li&gt;
&lt;li&gt;TT：type id，第二个字节，一般有十多个类型，像layout、id、drawable、anim等等；&lt;/li&gt;
&lt;li&gt;EEEE：资源在同类型下的索引。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="资源打包" scheme="https://ymlion.com/tags/%E8%B5%84%E6%BA%90%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>插件化之启动AppCompatActivity</title>
    <link href="https://ymlion.com/post/plugin-appcompat-activity/"/>
    <id>https://ymlion.com/post/plugin-appcompat-activity/</id>
    <published>2018-04-07T15:11:01.000Z</published>
    <updated>2018-04-08T03:49:50.015Z</updated>
    
    <content type="html"><![CDATA[<p>插件化实现过程中，资源与主题的处理是比较棘手的，而插件activity如果是<code>AppCompatActivity</code>，问题则会更多，像<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>并不能直接启动正常打包的插件apk，需要执行<code>assemblePlugin</code>任务进行编译打包，在<a href="https://github.com/didi/VirtualAPK/tree/master/virtualapk-gradle-plugin" target="_blank" rel="noopener">virtualapk-gradle-plugin</a>中对插件资源等进行了很多的修改，从而生成一个与宿主完美结合的插件。在理解插件化原理的过程中，如果只是看别人的代码或者文章，很可能只是一知半解的程度，所以相信很多人也是自己去写代码实现一个简单的插件化项目。这篇文章也由此而来，记录下实现插件化过程中启动<code>AppCompatActivity</code>中遇到的问题。</p><a id="more"></a><h3 id="了解AppCompatActivity"><a href="#了解AppCompatActivity" class="headerlink" title="了解AppCompatActivity"></a>了解AppCompatActivity</h3><p><code>AppCompatActivity</code>在<code>support-v7</code>包中，是android5.0之后推出的，用于兼容低版本使用<code>action bar</code>的新特性，并搭配<code>Theme.AppCompat</code>主题。通过查看该类的源代码，发现该类其实没有太多的内容，主要实现了<code>Activity</code>中生命周期和视图设置相关的方法，而这些方法都是通过一个代理类<code>AppCompatDelegate</code>来具体实现的，使用代理类都是调用<code>getDelegate()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppCompatDelegate <span class="title">getDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (mDelegate == <span class="keyword">null</span>) &#123;</span><br><span class="line">       mDelegate = AppCompatDelegate.create(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mDelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppCompatDelegate</code>类是抽象类，对于不同的系统版本，有不同的实现，下面是创建方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AppCompatDelegate <span class="title">create</span><span class="params">(Context context, Window window,</span></span></span><br><span class="line"><span class="function"><span class="params">        AppCompatCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplN(context, window, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV23(context, window, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV14(context, window, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV11(context, window, callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppCompatDelegateImplV9(context, window, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文基于<code>appcompat-v7-26.1.0</code>版本，通过上面的代码，能发现兼容至android2.3，同样也能猜到高版本<code>AppCompatDelegateImpl</code>依次继承自低版本，都是<code>AppCompatDelegateImplV9</code>的子类。<code>Activity</code>中有几个比较重要的方法就是通过该代理类来实现的：</p><ul><li><code>setContentView</code></li><li><code>findViewById</code></li><li>生命周期回调方法</li></ul><p>代理类的主要作用就是用于处理<code>action bar</code>，为当前activity的布局添加一层含有<code>action bar</code>的父布局<code>mSubDecor</code>，并在不同生命周期有不同的操作。在<code>AppCompatDelegateImplV9</code>中有两个比较重要的方法：</p><ul><li><code>ensureSubDecor</code>：如果<code>mSubDecor</code>没有被创建，则创建并执行界面调整相关操作，该方法在多个地方进行调用；</li><li><code>createSubDecor</code>：该方法就是创建<code>mSubDecor</code>的，而插件化中遇到的问题，也主要是来自该方法。</li></ul><p>插件化中遇到的问题与<code>createSubDecor</code>相关，所以先来看下<code>createSubDecor</code>方法的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ViewGroup <span class="title">createSubDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">    <span class="comment">// 首先就是关于AppCompatTheme的，使用AppCompatActivity就必须搭配该主题</span></span><br><span class="line">    <span class="keyword">if</span> (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123;</span><br><span class="line">        a.recycle();</span><br><span class="line">        <span class="comment">// 这里是第一个常遇到的问题，主题设置问题，不仅仅是插件化中会遇到</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"You need to use a Theme.AppCompat theme (or descendant) with this activity."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析主题属性，并进行相关设置</span></span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, <span class="keyword">false</span>)) &#123;<span class="comment">// title</span></span><br><span class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, <span class="keyword">false</span>)) &#123;<span class="comment">// action bar</span></span><br><span class="line">        <span class="comment">// Don't allow an action bar if there is no title.</span></span><br><span class="line">        requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY);</span><br><span class="line">    &#125;</span><br><span class="line">    mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, <span class="keyword">false</span>);</span><br><span class="line">    a.recycle();</span><br><span class="line">    <span class="comment">// Now let's make sure that the Window has installed its decor by retrieving it</span></span><br><span class="line">    mWindow.getDecorView();</span><br><span class="line">    <span class="keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);<span class="comment">// 创建inflater，这里也是有坑</span></span><br><span class="line">    ViewGroup subDecor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 下面就根据不同的属性，使用不同的布局文件创建subDecor</span></span><br><span class="line">    <span class="keyword">if</span> (!mWindowNoTitle) &#123;<span class="comment">// 有title</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            <span class="comment">// If we're floating, inflate the dialog title decor</span></span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_dialog_title_material, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// Floating windows can never have an action bar, reset the flags</span></span><br><span class="line">            mHasActionBar = mOverlayActionBar = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHasActionBar) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * This needs some explanation. As we can not use the android:theme attribute</span></span><br><span class="line"><span class="comment">             * pre-L, we emulate it by manually creating a LayoutInflater using a</span></span><br><span class="line"><span class="comment">             * ContextThemeWrapper pointing to actionBarTheme.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            mContext.getTheme().resolveAttribute(R.attr.actionBarTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">            Context themedContext;</span><br><span class="line">            <span class="keyword">if</span> (outValue.resourceId != <span class="number">0</span>) &#123;</span><br><span class="line">                themedContext = <span class="keyword">new</span> ContextThemeWrapper(mContext, outValue.resourceId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                themedContext = mContext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Now inflate the view using the themed context and set it as the content view</span></span><br><span class="line">            subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                    .inflate(R.layout.abc_screen_toolbar, <span class="keyword">null</span>);</span><br><span class="line">            mDecorContentParent = (DecorContentParent) subDecor</span><br><span class="line">                    .findViewById(R.id.decor_content_parent);</span><br><span class="line">            mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Propagate features to DecorContentParent</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (mOverlayActionBar) &#123;</span><br><span class="line">                mDecorContentParent.initFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mFeatureProgress) &#123;</span><br><span class="line">                mDecorContentParent.initFeature(Window.FEATURE_PROGRESS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mFeatureIndeterminateProgress) &#123;</span><br><span class="line">                mDecorContentParent.initFeature(Window.FEATURE_INDETERMINATE_PROGRESS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 无title</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlayActionMode) &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                    R.layout.abc_screen_simple_overlay_action_mode, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            <span class="comment">// If we're running on L or above, we can rely on ViewCompat's</span></span><br><span class="line">            <span class="comment">// setOnApplyWindowInsetsListener</span></span><br><span class="line">            ViewCompat.setOnApplyWindowInsetsListener(subDecor,</span><br><span class="line">                    <span class="keyword">new</span> OnApplyWindowInsetsListener() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> WindowInsetsCompat <span class="title">onApplyWindowInsets</span><span class="params">(View v,</span></span></span><br><span class="line"><span class="function"><span class="params">                                WindowInsetsCompat insets)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> top = insets.getSystemWindowInsetTop();</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> newTop = updateStatusGuard(top);</span><br><span class="line">                            <span class="keyword">if</span> (top != newTop) &#123;</span><br><span class="line">                                insets = insets.replaceSystemWindowInsets(</span><br><span class="line">                                        insets.getSystemWindowInsetLeft(),</span><br><span class="line">                                        newTop,</span><br><span class="line">                                        insets.getSystemWindowInsetRight(),</span><br><span class="line">                                        insets.getSystemWindowInsetBottom());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Now apply the insets on our view</span></span><br><span class="line">                            <span class="keyword">return</span> ViewCompat.onApplyWindowInsets(v, insets);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Else, we need to use our own FitWindowsViewGroup handling</span></span><br><span class="line">            ((FitWindowsViewGroup) subDecor).setOnFitSystemWindowsListener(</span><br><span class="line">                    <span class="keyword">new</span> FitWindowsViewGroup.OnFitSystemWindowsListener() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFitSystemWindows</span><span class="params">(Rect insets)</span> </span>&#123;</span><br><span class="line">                            insets.top = updateStatusGuard(insets.top);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"AppCompat does not support the current theme features: &#123; "</span></span><br><span class="line">                        + <span class="string">"windowActionBar: "</span> + mHasActionBar</span><br><span class="line">                        + <span class="string">", windowActionBarOverlay: "</span>+ mOverlayActionBar</span><br><span class="line">                        + <span class="string">", android:windowIsFloating: "</span> + mIsFloating</span><br><span class="line">                        + <span class="string">", windowActionModeOverlay: "</span> + mOverlayActionMode</span><br><span class="line">                        + <span class="string">", windowNoTitle: "</span> + mWindowNoTitle</span><br><span class="line">                        + <span class="string">" &#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDecorContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTitleView = (TextView) subDecor.findViewById(R.id.title);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make the decor optionally fit system windows, like the window's decor</span></span><br><span class="line">    ViewUtils.makeOptionalFitsSystemWindows(subDecor);</span><br><span class="line">    <span class="keyword">final</span> ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">            R.id.action_bar_activity_content);</span><br><span class="line">    <span class="keyword">final</span> ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    <span class="keyword">if</span> (windowContentView != <span class="keyword">null</span>) &#123;<span class="comment">// 原有view放到新的contentView中</span></span><br><span class="line">        <span class="comment">// There might be Views already added to the Window's content view so we need to</span></span><br><span class="line">        <span class="comment">// migrate them to our content view</span></span><br><span class="line">        <span class="keyword">while</span> (windowContentView.getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = windowContentView.getChildAt(<span class="number">0</span>);</span><br><span class="line">            windowContentView.removeViewAt(<span class="number">0</span>);</span><br><span class="line">            contentView.addView(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Change our content FrameLayout to use the android.R.id.content id.</span></span><br><span class="line">        <span class="comment">// Useful for fragments.</span></span><br><span class="line">        windowContentView.setId(View.NO_ID);</span><br><span class="line">        contentView.setId(android.R.id.content);</span><br><span class="line">        <span class="comment">// The decorContent may have a foreground drawable set (windowContentOverlay).</span></span><br><span class="line">        <span class="comment">// Remove this as we handle it ourselves</span></span><br><span class="line">        <span class="keyword">if</span> (windowContentView <span class="keyword">instanceof</span> FrameLayout) &#123;</span><br><span class="line">            ((FrameLayout) windowContentView).setForeground(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now set the Window's content view with the decor</span></span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line">    contentView.setAttachListener(<span class="keyword">new</span> ContentFrameLayout.OnAttachListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedFromWindow</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            dismissPopups();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道，该方法主要做了三件事情：</p><ol><li>解析主题中设置的属性，并执行相应处理；</li><li>根据不同属性，解析相应的布局文件作为<code>mSubDecor</code>；</li><li>将原有window布局中添加的view移动到<code>mSubDecor</code>中的<code>contentView</code>中，并将当前的window布局替换为<code>mSubDecor</code>。</li></ol><p>插件化中关于<code>AppCompatActivity</code>遇到的问题就主要涉及到<code>Theme.AppCompat</code>和view解析。</p><h3 id="Theme-AppCompat问题"><a href="#Theme-AppCompat问题" class="headerlink" title="Theme.AppCompat问题"></a>Theme.AppCompat问题</h3><p><code>AppCompatActivity</code>与<code>Theme.AppCompat</code>相关主题搭配才行，这里就引出了第一个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.</span><br></pre></td></tr></table></figure><p>很眼熟，上面提到过，就是<code>createSubDecor</code>代码中最开始抛出的那个异常。很明显就是主题设置不对，但在插件中主题肯定是设置正常的，所以问题的关键在activity创建时，没有对主题进行设置。</p><p>在<code>ActivityThread.performLaunchActivity()</code>方法中，有这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line"><span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">    activity.setTheme(theme);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是设置主题资源id，是在activity创建之后，执行<code>onCreate</code>方法之前执行，代码很简单，当<code>theme</code>为0时，是不会设置的，所以不能让<code>theme</code>为0。<code>theme</code>是通过<code>activityInfo</code>获取，而<code>activityInfo</code>是解析<code>AndroidManifest.xml</code>获取的，所以大约有三种方式可以修改<code>theme</code>：</p><ul><li>可以在<code>Instrumentation.callActivityOnCreate</code>方法中获取真正的主题资源id并设置，也就是在上面这段代码之后；</li><li>同样可以修改<code>r.activityInfo</code>中的数据，即在反射设置的<code>ActivityThread.mH</code>的<code>Callback</code>回调中，获取真正资源id并赋值到<code>r.activityInfo</code>；</li><li>在插件<code>AndroidManifest.xml</code>中，单独设置对应activity的主题。</li></ul><p>所以，该问题出现的原因就是没有在<code>AndroidManifest.xml</code>中设置该activity的主题，只是设置了application的主题，而拦截对应的方法时并没有重新设置该activity的主题为application的主题。解决方法上面已经给出，推荐前两种方法。</p><h3 id="View解析问题"><a href="#View解析问题" class="headerlink" title="View解析问题"></a>View解析问题</h3><p>在解决了主题问题之后，继续执行<code>createSubDecor</code>方法中的代码，然后就遇到一个令人崩溃的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: android.support.v7.widget.ContentFrameLayout cannot be cast to android.support.v7.widget.ContentFrameLayout</span><br></pre></td></tr></table></figure><p>上面这个异常可能出现在<code>createSubDecor</code>方法的获取<code>contentView</code>时，也可能出现在执行<code>mDecorContentParent.setWindowCallback(getWindowCallback())</code>时，深入该方法也是会有<code>findViewById</code>查找<code>ContentFrameLayout</code>对应的view的操作。</p><p>该异常第一眼看上去是不可思议的，同样的类名怎么可能不是同一个类。但通过<a href="https://ymlion.com/post/android-classloader/">Android ClassLoader分析</a>，很容易理解类的<code>ClassLoader</code>不同时，则两个类是不同的。知道了该异常的原因，就要找到该异常出现的原因。如果单独靠代码分析，很难找到出现的原因，还好可以调试。因为是在android5.1的模拟器上测试的，而我的sdk源码是26，所以这个问题找了好久。后来想通过android8.0的模拟器进行调试，却发现android8.0上没有这个问题。最后还是通过sdk22的源码进行调试找到了出现的原因。</p><p><code>AppCompatActivity</code>中的<code>action bar</code>相关view使用的都是<code>appcompat-v7</code>包中的自定义view，当插件和宿主在同一个进程时，在android7.0以下会触发这个异常。既然是<code>ClassLoader</code>不同，则需要找到view创建的地方，最终定位到<code>LayoutInflater.createView</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Constructor&lt;? extends View&gt;&gt; sConstructorMap =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Constructor&lt;? extends View&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取缓存中的构造方法</span></span><br><span class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;<span class="comment">// 构造方法为null</span></span><br><span class="line">            <span class="comment">// 获取class loader并缓存构造方法</span></span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                    prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">            </span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125;<span class="comment">// 省略部分代码</span></span><br><span class="line">        Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (mConstructorArgs[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Fill in the context if not already within inflation.</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = mContext;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args = mConstructorArgs;</span><br><span class="line">        args[<span class="number">1</span>] = attrs;</span><br><span class="line">        <span class="comment">// 使用构造方法创建view</span></span><br><span class="line">        <span class="keyword">final</span> View view = constructor.newInstance(args);</span><br><span class="line">        <span class="keyword">if</span> (view <span class="keyword">instanceof</span> ViewStub) &#123;</span><br><span class="line">            <span class="comment">// Use the same context when inflating ViewStub later.</span></span><br><span class="line">            <span class="keyword">final</span> ViewStub viewStub = (ViewStub) view;</span><br><span class="line">            viewStub.setLayoutInflater(cloneInContext((Context) args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法作用很清晰，即获取当前view的构造方法，并创建view。在代码最上面给出了<code>sConstructorMap</code>的定义，关键点就在这里，该变量是<code>static final</code>的，所以在同一个进程时，<code>sConstructorMap</code>是不变的，并且前面出现的view构造方法是已经缓存的。因此，当插件<code>AppCompatActivity</code>启动时，<code>ContentFrameLayout</code>如果在宿主中已经加载过，即宿主activity也是<code>AppCompatActivity</code>，就会报上面的异常。同样可以推断出，第三方的view如果在宿主中的布局中有，在插件中再次出现也肯定会报异常。</p><p>既然出现的原因已经分析，那么解决办法自然也能想到：清除<code>sConstructorMap</code>中与宿主相同view的构造方法，有两种实现：</p><ul><li>在activity创建之后，调用<code>onCreate</code>之前，即在<code>Instrumentation.callActivityOnCreate</code>方法中先反射清除掉<code>sConstructorMap</code>中和插件activity不同<code>ClassLoader</code>的view构造方法；</li><li>在新的进程中启动插件activity，<code>static final</code>只是针对同一进程，即在<code>AndroidManifest.xml</code>中声明activity的<code>process</code>。</li></ul><p>上面说过，android7.0及以上版本是没有这个问题的，所以找到源码中的区别，并为自己所用，就实现了第一种方法。下面看下两者区别是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    <span class="keyword">if</span> (constructor != <span class="keyword">null</span> &amp;&amp; !verifyClassLoader(constructor)) &#123;<span class="comment">// 区别就在这里</span></span><br><span class="line">        constructor = <span class="keyword">null</span>;</span><br><span class="line">        sConstructorMap.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 后面的代码相同，省略了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoader BOOT_CLASS_LOADER = LayoutInflater.class.getClassLoader();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">verifyClassLoader</span><span class="params">(Constructor&lt;? extends View&gt; constructor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClassLoader constructorLoader = constructor.getDeclaringClass().getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (constructorLoader == BOOT_CLASS_LOADER) &#123;<span class="comment">// 是否是BootClassLoader</span></span><br><span class="line">        <span class="comment">// fast path for boot class loader (most common case?) - always ok</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// in all normal cases (no dynamic code loading), we will exit the following loop on the</span></span><br><span class="line">    <span class="comment">// first iteration (i.e. when the declaring classloader is the contexts class loader).</span></span><br><span class="line">    ClassLoader cl = mContext.getClassLoader();</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">// 是否是当前activity的class loader或其parent加载的</span></span><br><span class="line">        <span class="keyword">if</span> (constructorLoader == cl) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">    &#125; <span class="keyword">while</span> (cl != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码拿来直接用就好了，实现简单明了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>插件化过程中，遇到的问题肯定不止这两个，这篇文章主要写这两个问题，一是熟悉下<code>AppCompatActivity</code>，了解其主要作用；二是这两个问题比较具有代表性，解决方法也有代表性。所以，在深入研究插件化过程中，所有遇到的问题解决方法还是需要深入研究源码，需要更多的耐心和细心。</p><blockquote><p>这两个问题具体的代码实现以及插件化的demo，在<a href="https://github.com/YMlion/plugin-coding" target="_blank" rel="noopener">这里</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;插件化实现过程中，资源与主题的处理是比较棘手的，而插件activity如果是&lt;code&gt;AppCompatActivity&lt;/code&gt;，问题则会更多，像&lt;a href=&quot;https://github.com/didi/VirtualAPK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualAPK&lt;/a&gt;并不能直接启动正常打包的插件apk，需要执行&lt;code&gt;assemblePlugin&lt;/code&gt;任务进行编译打包，在&lt;a href=&quot;https://github.com/didi/VirtualAPK/tree/master/virtualapk-gradle-plugin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;virtualapk-gradle-plugin&lt;/a&gt;中对插件资源等进行了很多的修改，从而生成一个与宿主完美结合的插件。在理解插件化原理的过程中，如果只是看别人的代码或者文章，很可能只是一知半解的程度，所以相信很多人也是自己去写代码实现一个简单的插件化项目。这篇文章也由此而来，记录下实现插件化过程中启动&lt;code&gt;AppCompatActivity&lt;/code&gt;中遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="AppCompat" scheme="https://ymlion.com/tags/AppCompat/"/>
    
  </entry>
  
  <entry>
    <title>VirtualAPK原理分析之Service启动</title>
    <link href="https://ymlion.com/post/virtualapk-analysis-service/"/>
    <id>https://ymlion.com/post/virtualapk-analysis-service/</id>
    <published>2018-03-19T08:30:01.000Z</published>
    <updated>2018-04-08T03:49:50.109Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.google.cn/guide/components/services.html?hl=zh-cn" target="_blank" rel="noopener">Service</a>启动相对于activity来说，没有那么复杂，而且生命周期很简单，启动插件中的service，同样需要了解service启动流程及生命周期。service的启动流程相对简单，主要涉及<code>ActivityManagerService</code>和<code>ActivityThread</code>两个类，前者是service启动及生命周期控制类，后者是service启动和生命周期的执行类。</p><a id="more"></a><p>了解service的启动流程及生命周期后，能够发现和activity比较类似，那是否能够和activity插件化原理相同呢？通过实现的源码来看是不同的，至于为什么不同，在分析完源码之后再倒推原因。</p><h3 id="预注册"><a href="#预注册" class="headerlink" title="预注册"></a>预注册</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.didi.virtualapk.delegate.LocalService"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Daemon Service running in child process --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.didi.virtualapk.delegate.RemoteService"</span> <span class="attr">android:process</span>=<span class="string">":daemon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"$&#123;applicationId&#125;.intent.ACTION_DAEMON_SERVICE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>CoreLibrary</code>的<code>AndroidManifest.xml</code>中预注册了两个service，对应于不同的进程，因为service在单独的进程中执行任务是比较常见的。<code>RemoteService</code>继承自<code>LocalService</code>，大部分逻辑都是在<code>LocalService</code>中进行。通过预注册可以知道，前期的逻辑和activity是一样的，都是“偷梁换柱”，下面就看下service启动是如何“偷梁换柱”。</p><h3 id="hook-AMS"><a href="#hook-AMS" class="headerlink" title="hook AMS"></a>hook AMS</h3><p><a href="http://ymlion.com/post/virtualapk-analysis-2/">activity启动</a>的偷梁换柱主要是在<code>Instrumentation</code>中，在上一篇中其实也说过在<code>AMS</code>中也是可以的，activity和service一样，启动逻辑首先是在<code>AMS</code>中进行的。service启动涉及的类比较少，只能在<code>AMS</code>中做手脚。在<a href="http://ymlion.com/post/virtualapk-analysis-1/">加载分析</a>中说过，在一开始就hook了<code>AMS</code>，主要是用于service控制的，下面看下<code>ActivityManagerProxy</code>这个代理类的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"startService"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> startService(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"stopService"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> stopService(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"stopServiceToken"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> stopServiceToken(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"bindService"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> bindService(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"unbindService"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> unbindService(proxy, method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getIntentSender"</span>.equals(method.getName())) &#123;</span><br><span class="line">        getIntentSender(method, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"overridePendingTransition"</span>.equals(method.getName()))&#123;</span><br><span class="line">        overridePendingTransition(method, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码省略了异常捕获及日志部分，整体总共拦截了7个方法，看下拦截之后的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在LocalService中定义的常量，源码是用RemoteService调用的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_TARGET = <span class="string">"target"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_COMMAND = <span class="string">"command"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_PLUGIN_LOCATION = <span class="string">"plugin_location"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXTRA_COMMAND_START_SERVICE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXTRA_COMMAND_STOP_SERVICE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXTRA_COMMAND_BIND_SERVICE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXTRA_COMMAND_UNBIND_SERVICE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">startService</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    IApplicationThread appThread = (IApplicationThread) args[<span class="number">0</span>];</span><br><span class="line">    Intent target = (Intent) args[<span class="number">1</span>];</span><br><span class="line">    ResolveInfo resolveInfo = <span class="keyword">this</span>.mPluginManager.resolveService(target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == resolveInfo || <span class="keyword">null</span> == resolveInfo.serviceInfo) &#123;</span><br><span class="line">        <span class="comment">// is host service</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.mActivityManager, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> startDelegateServiceForTarget(target, resolveInfo.serviceInfo, <span class="keyword">null</span>, RemoteService.EXTRA_COMMAND_START_SERVICE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">bindService</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Intent target = (Intent) args[<span class="number">2</span>];</span><br><span class="line">    ResolveInfo resolveInfo = <span class="keyword">this</span>.mPluginManager.resolveService(target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == resolveInfo || <span class="keyword">null</span> == resolveInfo.serviceInfo) &#123;</span><br><span class="line">        <span class="comment">// is host service</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.mActivityManager, args);</span><br><span class="line">    &#125;</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    PluginUtil.putBinder(bundle, <span class="string">"sc"</span>, (IBinder) args[<span class="number">4</span>]);</span><br><span class="line">    startDelegateServiceForTarget(target, resolveInfo.serviceInfo, bundle, RemoteService.EXTRA_COMMAND_BIND_SERVICE);</span><br><span class="line">    mPluginManager.getComponentsHandler().remberIServiceConnection((IBinder) args[<span class="number">4</span>], target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startDelegateServiceForTarget</span><span class="params">(Intent target, ServiceInfo serviceInfo, Bundle extras, <span class="keyword">int</span> command)</span> </span>&#123;</span><br><span class="line">    Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command);</span><br><span class="line">    <span class="keyword">return</span> mPluginManager.getHostContext().startService(wrapperIntent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">wrapperTargetIntent</span><span class="params">(Intent target, ServiceInfo serviceInfo, Bundle extras, <span class="keyword">int</span> command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// fill in service with ComponentName</span></span><br><span class="line">    target.setComponent(<span class="keyword">new</span> ComponentName(serviceInfo.packageName, serviceInfo.name));</span><br><span class="line">    String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();</span><br><span class="line">    <span class="comment">// start delegate service to run plugin service inside</span></span><br><span class="line">    <span class="keyword">boolean</span> local = PluginUtil.isLocalService(serviceInfo);</span><br><span class="line">    Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setClass(mPluginManager.getHostContext(), delegate);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_TARGET, target);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_COMMAND, command);</span><br><span class="line">    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);</span><br><span class="line">    <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtras(extras);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看上面4个方法的实现，<code>stopService</code>、<code>stopServiceToken</code>、<code>unbindService</code>的实现和<code>startService</code>差不多，区别就是<code>startDelegateServiceForTarget</code>第4个参数不同，在最上面也把对应的常量列了出来。</p><p><code>startService</code>和<code>bindService</code>及其他方法，在一开始也是判断当前的service是否是插件中的，如果不是则执行不处理，交由<code>AMS</code>自己处理；如果是插件service，则执行<code>startDelegateServiceForTarget</code>，首先调用<code>wrapperTargetIntent</code>来偷梁换柱，将插件service替换为预注册的<code>LocalService</code>或者<code>RemoteService</code>，最后再调用<code>Context.startService</code>启动预注册的service中的一个。</p><p><code>bindService</code>和<code>startService</code>启动方式是不相同的，在这里处理时肯定也是不同的，<code>bindService</code>有一个参数<code>adnroid.content.ServiceConnection</code>，用于监听service状态，不可为<code>null</code>，在<code>android.app.ContextImpl</code>中看下该参数的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags, Handler</span></span></span><br><span class="line"><span class="function"><span class="params">        handler, UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;<span class="comment">// 实例化IServiceConnection</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 调用AMS的bindService方法，sd作为第5个参数</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>ServiceConnection</code>对象参数最终为了获取<code>IServiceConnection</code>实例，并传递给<code>AMS</code>，所以<code>AMS</code>代理类中的<code>bindService</code>将<code>IServiceConnection</code>对象保存了下来，以作后用。</p><p>到这里，“偷梁换柱”的工作已经完成了，后面就是如何恢复插件service并启动了，按照activity恢复的逻辑，好像service恢复只有一条路走，就是对<code>ActivityThread</code>中的<code>mH</code>设置回调，在service创建之前替换为插件service。但实际上却不是这样的，这也是文章开始说的不同，原因后面再推。</p><h3 id="Service代理"><a href="#Service代理" class="headerlink" title="Service代理"></a>Service代理</h3><p>既然service和activity不一样，已经没有恢复插件service的地方了，那预注册的service就真正启动了。<code>LocalService</code>和<code>RemoteService</code>是有具体实现的，逻辑主要在<code>LocalService</code>中（前面也说过，是不是有所怀疑）。前面<code>AMS</code>代理中实现的是，无论是拦截的哪个方法，都是调用的<code>Context.startService</code>启动service。service实例只能有一个，每次调用<code>startService</code>不会再创建service，而是执行<code>onStartCommand</code>回调，这也能猜到所有的逻辑都在<code>LocalService.onStartCommand</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == intent || !intent.hasExtra(EXTRA_TARGET) || !intent.hasExtra(EXTRA_COMMAND)) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line">    Intent target = intent.getParcelableExtra(EXTRA_TARGET);</span><br><span class="line">    <span class="keyword">int</span> command = intent.getIntExtra(EXTRA_COMMAND, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == target || command &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component = target.getComponent();</span><br><span class="line">    LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component);</span><br><span class="line">    <span class="comment">// ClassNotFoundException when unmarshalling in Android 5.1</span></span><br><span class="line">    target.setExtrasClassLoader(plugin.getClassLoader());</span><br><span class="line">    <span class="keyword">switch</span> (command) &#123;</span><br><span class="line">        <span class="keyword">case</span> EXTRA_COMMAND_START_SERVICE: &#123;<span class="comment">// startService</span></span><br><span class="line">            ActivityThread mainThread = (ActivityThread)ReflectUtil.getActivityThread(getBaseContext());</span><br><span class="line">            IApplicationThread appThread = mainThread.getApplicationThread();</span><br><span class="line">            Service service;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123;<span class="comment">// service是否启动</span></span><br><span class="line">                service = <span class="keyword">this</span>.mPluginManager.getComponentsHandler().getService(component);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();<span class="comment">// 创建插件service</span></span><br><span class="line">                    Application app = plugin.getApplication();</span><br><span class="line">                    IBinder token = appThread.asBinder();</span><br><span class="line">                    Method attach = service.getClass().getMethod(<span class="string">"attach"</span>, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);</span><br><span class="line">                    IActivityManager am = mPluginManager.getActivityManager();</span><br><span class="line">                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);<span class="comment">// 执行attach</span></span><br><span class="line">                    service.onCreate();<span class="comment">// 执行onCreate</span></span><br><span class="line">                    <span class="keyword">this</span>.mPluginManager.getComponentsHandler().rememberService(component, service);<span class="comment">// 保存</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">return</span> START_STICKY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            service.onStartCommand(target, <span class="number">0</span>, <span class="keyword">this</span>.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EXTRA_COMMAND_BIND_SERVICE: &#123;<span class="comment">// bindService</span></span><br><span class="line">            ActivityThread mainThread = (ActivityThread)ReflectUtil.getActivityThread(getBaseContext());</span><br><span class="line">            IApplicationThread appThread = mainThread.getApplicationThread();</span><br><span class="line">            Service service = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123;</span><br><span class="line">                service = <span class="keyword">this</span>.mPluginManager.getComponentsHandler().getService(component);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();</span><br><span class="line">                    Application app = plugin.getApplication();</span><br><span class="line">                    IBinder token = appThread.asBinder();</span><br><span class="line">                    Method attach = service.getClass().getMethod(<span class="string">"attach"</span>, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);</span><br><span class="line">                    IActivityManager am = mPluginManager.getActivityManager();</span><br><span class="line">                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);</span><br><span class="line">                    service.onCreate();</span><br><span class="line">                    <span class="keyword">this</span>.mPluginManager.getComponentsHandler().rememberService(component, service);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">// 回调IServiceConnection</span></span><br><span class="line">                IBinder binder = service.onBind(target);</span><br><span class="line">                IBinder serviceConnection = PluginUtil.getBinder(intent.getExtras(), <span class="string">"sc"</span>);</span><br><span class="line">                IServiceConnection iServiceConnection = IServiceConnection.Stub.asInterface(serviceConnection);</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">                    ReflectUtil.invokeNoException(IServiceConnection.class, iServiceConnection, <span class="string">"connected"</span>,</span><br><span class="line">                            <span class="keyword">new</span> Class[]&#123;ComponentName.class, IBinder.class, <span class="keyword">boolean</span>.class&#125;,</span><br><span class="line">                            <span class="keyword">new</span> Object[]&#123;component, binder, <span class="keyword">false</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    iServiceConnection.connected(component, binder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EXTRA_COMMAND_STOP_SERVICE: &#123;<span class="comment">// stopService or stopServiceToken</span></span><br><span class="line">            Service service = <span class="keyword">this</span>.mPluginManager.getComponentsHandler().forgetService(component); <span class="comment">//移除</span></span><br><span class="line">            service.onDestroy();<span class="comment">//执行onDestroy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> EXTRA_COMMAND_UNBIND_SERVICE: &#123;<span class="comment">// unbindService</span></span><br><span class="line">            Service service = <span class="keyword">this</span>.mPluginManager.getComponentsHandler().forgetService(component);<span class="comment">//移除</span></span><br><span class="line">            service.onUnbind(target);<span class="comment">// 执行onUnbind</span></span><br><span class="line">            service.onDestroy();<span class="comment">// 执行onDestroy</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，根据前面设置的不同命令，执行对应的service创建和销毁。<code>stopService</code>和<code>unbindService</code>对应的命令比较简单，执行对应的生命周期回调即可。插件service的创建相对复杂，主要是三步：</p><ul><li>使用自定义的插件<code>ClassLoader</code>创建service实例；</li><li>执行<code>Service.attach</code>方法，对service运行环境初始化；</li><li>执行<code>onCreate</code>、<code>onStartCommand</code>生命周期回调。</li></ul><p><code>bindService</code>除了上面三步，还要执行<code>ServiceConnection</code>的回调。插件service创建及生命周期处理原理到这里就很清晰了，即通过预注册service作为代理，通过不同的命令参数执行插件service对应的操作。为什么这么做呢？这就是activity和service的不同了，这里我们倒推一下原因。</p><p>还记得activity插件化中，对于activity生命周期的回调，在插件化框架中是没有处理的，完全交由系统去分发回调事件，这样做的原因也很容易想到，就是activity回调不是我们写代码控制的，而是系统根据我们不同的操作，如返回、启动新activity、显示<code>dialog</code>等，来处理activity的生命周期，我们程序无法完全判断activity生命周期回调逻辑，只能被动接受系统的逻辑。而service不同，其生命周期简单，<code>onCreate</code>、<code>onStartCommand</code>、<code>onBind</code>都是程序中启动service时执行，而<code>onDestroy</code>、<code>onUnbind</code>则是执行<code>stopService</code>或者<code>unbindService</code>时执行的，所以是我们程序控制service的生命周期。因此，我们不需要像启动activity那么复杂，service插件化只需要拦截<code>AMS</code>之后直接创建或者销毁就好。</p><p>既然这样做可以，为什么还要使用service代理来处理插件service的创建及生命周期？如果直接在<code>AMS</code>代理类中直接处理，插件service就不能算是<a href="https://developer.android.google.cn/guide/components/services.html?hl=zh-cn" target="_blank" rel="noopener">Service</a>了，<a href="https://developer.android.google.cn/guide/components/services.html?hl=zh-cn" target="_blank" rel="noopener">Service</a>是应用组件，有自己的生命周期及运行时优先级，甚至有自己的进程。所以使用service代理就是一个很好的方法，这就让插件service成为了真正的<a href="https://developer.android.google.cn/guide/components/services.html?hl=zh-cn" target="_blank" rel="noopener">Service</a>。</p><blockquote><p><code>Service</code> 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总结下插件service处理过程：</p><ol><li>预注册services，用于替换插件service；</li><li>hook <code>AMS</code>，拦截对应的service方法，并替换插件service，启动预注册service；</li><li>通过将预注册service作为代理，实现插件service创建及生命周期回调。</li></ol><p>通过上面的分析，也看到了service和activity的区别，及service代理的巧妙。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.google.cn/guide/components/services.html?hl=zh-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Service&lt;/a&gt;启动相对于activity来说，没有那么复杂，而且生命周期很简单，启动插件中的service，同样需要了解service启动流程及生命周期。service的启动流程相对简单，主要涉及&lt;code&gt;ActivityManagerService&lt;/code&gt;和&lt;code&gt;ActivityThread&lt;/code&gt;两个类，前者是service启动及生命周期控制类，后者是service启动和生命周期的执行类。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="VirtualAPK" scheme="https://ymlion.com/tags/VirtualAPK/"/>
    
  </entry>
  
  <entry>
    <title>VirtualAPK原理分析之Activity启动</title>
    <link href="https://ymlion.com/post/virtualapk-analysis-2/"/>
    <id>https://ymlion.com/post/virtualapk-analysis-2/</id>
    <published>2018-03-15T04:20:01.000Z</published>
    <updated>2018-04-08T03:49:50.106Z</updated>
    
    <content type="html"><![CDATA[<p>启动activity是在插件化中是最为复杂的，既有启动模式的多样性，又有生命周期的多变性，更是涉及到资源加载。启动一个插件中的activity，难点在于该activity没有在宿主中注册，直接启动肯定没法找到这个activity。如何解决，需要对activity启动流程比较熟悉。activity启动流程过于复杂，涉及类也众多，但主要需要关注的有<code>Activity</code>、<code>Instrumentation</code>、<code>AMS</code>、<code>ActivityThread</code>这4个类。</p><a id="more"></a><p>插件化中通常的解决方法就是在宿主中预注册多个不同启动模式的activity，在启动流程中的某个阶段将要启动的目标activity替换成对应的预注册过的activity，使得流程继续下去，但在最后要创建activity之前再替换为目标activity，并用自定义的<code>DexClassLoader</code>实例去加载目标activity，最终启动的是目标activity。就用一个偷梁换柱，骗过系统，最终实现activity启动，也算是巧妙。下面看下<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>中是如何实现的偷梁换柱。</p><h2 id="activity预注册"><a href="#activity预注册" class="headerlink" title="activity预注册"></a>activity预注册</h2><p><a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>的文档中说过不用在宿主中预注册activity，那上面的方法就没法实现，但实际是怎样的呢？我们在<code>CoreLibrary</code>中看到了一个文件<a href="https://github.com/didi/VirtualAPK/blob/master/CoreLibrary/src/main/AndroidManifest.xml" target="_blank" rel="noopener">AndroidManifest.xml</a>，在里面揭示了真相：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".A$1"</span> <span class="attr">android:launchMode</span>=<span class="string">"standard"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".A$2"</span> <span class="attr">android:launchMode</span>=<span class="string">"standard"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Translucent"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Stub Activities --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".B$1"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Stub Activities --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".C$1"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Stub Activities --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".D$1"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>每个启动模式都有很多个预注册的activity，上面省略了大部分，<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>提前已经预注册过了，这样处理相对于在宿主中注册更加方便了，不用用户考虑预注册多少activity的问题了。</p><h2 id="偷梁换柱之骗过系统"><a href="#偷梁换柱之骗过系统" class="headerlink" title="偷梁换柱之骗过系统"></a>偷梁换柱之骗过系统</h2><p>使用预注册的activity骗过系统这一步，在activity启动流程中有不止一处可以实现，<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>中涉及了其中两处。在上一篇加载分析中，第二步就是为此做准备的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook掉ActivityThread中的mInstrumentation和为mH添加Callback</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hookInstrumentationAndHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Instrumentation baseInstrumentation = ReflectUtil.getInstrumentation(<span class="keyword">this</span>.mContext);</span><br><span class="line">        <span class="keyword">if</span> (baseInstrumentation.getClass().getName().contains(<span class="string">"lbe"</span>)) &#123;</span><br><span class="line">            <span class="comment">// reject executing in paralell space, for example, lbe.</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> VAInstrumentation instrumentation = <span class="keyword">new</span> VAInstrumentation(<span class="keyword">this</span>, baseInstrumentation);</span><br><span class="line">        Object activityThread = ReflectUtil.getActivityThread(<span class="keyword">this</span>.mContext);</span><br><span class="line">        ReflectUtil.setInstrumentation(activityThread, instrumentation);</span><br><span class="line">        ReflectUtil.setHandlerCallback(<span class="keyword">this</span>.mContext, instrumentation);</span><br><span class="line">        <span class="keyword">this</span>.mInstrumentation = instrumentation;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Instrumentation</code>类和activity的创建、整个生命周期回调都是在该类中执行的，<code>startActivity</code>会执行该类的<code>execStartActivity</code>方法，所以该方法是一个很好替换为预注册activity的好地方，<code>VAInstrumentation</code>中重写了该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这一步是找到真正正确的intent中ComponentName实例，因为原来的包名可能不对</span></span><br><span class="line">    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);<span class="comment">// ①</span></span><br><span class="line">    <span class="comment">// null component is an implicitly intent</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.i(TAG, String.format(<span class="string">"execStartActivity[%s : %s]"</span>, intent.getComponent().getPackageName(),</span><br><span class="line">                intent.getComponent().getClassName()));</span><br><span class="line">        <span class="comment">// resolve intent with Stub Activity if needed</span></span><br><span class="line">        <span class="keyword">this</span>.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent); <span class="comment">// ②</span></span><br><span class="line">    &#125;</span><br><span class="line">    ActivityResult result = realExecStartActivity(who, contextThread, token, target,</span><br><span class="line">                intent, requestCode, options); <span class="comment">// ③</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法有多个重载方法，这里的目的都是一样的，替换intent中的activity对应的包名和类名。如果是插件中的activity，第①步保证了包名和类名的正确性。第②步是执行替换操作：将目标activity包名和类名保存到intent的<code>Bundle</code>对象中，并找到目标activity对应的<code>ActivityInfo</code>，根据启动模式和主题去匹配预注册的activity，最后替换为预注册的某个activity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markIntentIfNeeded</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String targetPackageName = intent.getComponent().getPackageName();</span><br><span class="line">    String targetClassName = intent.getComponent().getClassName();</span><br><span class="line">    <span class="comment">// search map and return specific launchmode stub activity</span></span><br><span class="line">    <span class="keyword">if</span> (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != <span class="keyword">null</span>) &#123;<span class="comment">// 保存目标activity</span></span><br><span class="line">        intent.putExtra(Constants.KEY_IS_PLUGIN, <span class="keyword">true</span>);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);</span><br><span class="line">        dispatchStubActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchStubActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    ComponentName component = intent.getComponent();</span><br><span class="line">    String targetClassName = intent.getComponent().getClassName();</span><br><span class="line">    LoadedPlugin loadedPlugin = mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">    ActivityInfo info = loadedPlugin.getActivityInfo(component);<span class="comment">// 找到目标activity对应的ActivityInfo</span></span><br><span class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can not find "</span> + component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> launchMode = info.launchMode;</span><br><span class="line">    Resources.Theme themeObj = loadedPlugin.getResources().newTheme();</span><br><span class="line">    themeObj.applyStyle(info.theme, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 根据启动模式和主题去匹配预注册的activity</span></span><br><span class="line">    String stubActivity = mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj);</span><br><span class="line">    Log.i(TAG, String.format(<span class="string">"dispatchStubActivity,[%s -&gt; %s]"</span>, targetClassName, stubActivity));</span><br><span class="line">    intent.setClassName(mContext, stubActivity); <span class="comment">// 设置预注册activity包名和类名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第③步是反射<code>execStartActivity</code>方法，因为该方法是隐藏的，只对系统可见，所以必须反射才能执行原始<code>Instrumentation</code>对象<code>mBase</code>中的该方法。到此为止，已经骗过系统，让系统去找预注册的activity，而非目标activity，下一步就是在activity创建之前再替换回目标activity。</p><h2 id="偷梁换柱之实现目标"><a href="#偷梁换柱之实现目标" class="headerlink" title="偷梁换柱之实现目标"></a>偷梁换柱之实现目标</h2><p>前面说过<code>Instrumentation</code>中执行activity的创建，主要就是加载目标activity类，对应的方法就是<code>newActivity</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl.loadClass(className);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        LoadedPlugin plugin = <span class="keyword">this</span>.mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">        String targetClassName = PluginUtil.getTargetActivity(intent);</span><br><span class="line">        Log.i(TAG, String.format(<span class="string">"newActivity[%s : %s]"</span>, className, targetClassName));</span><br><span class="line">        <span class="keyword">if</span> (targetClassName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</span><br><span class="line">            activity.setIntent(intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// for 4.1+</span></span><br><span class="line">                ReflectUtil.setField(ContextThemeWrapper.class, activity, <span class="string">"mResources"</span>, plugin.getResources());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                <span class="comment">// ignored.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> activity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mBase.newActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是插件中的activity，则会捕获异常，然后使用插件中的<code>DexClassLoader</code>去加载目标activity类，创建了activity之后，再次设置上一篇初始化时就保存好的插件的<code>Resources</code>对象，因为<code>ContextThemeWrapper</code>是<code>Activity</code>的父类，<code>getResources</code>方法在<code>ContextThemeWrapper</code>中有重写，而该方法就是返回<code>mResources</code>，这里设置了，在activity创建之后用到的时候获取的就是插件中的<code>Resources</code>对象。</p><p>这样，目标activity就创建成功了，但该activity还有些变量需要修改。activity创建成功之后，会执行<code>activity.attach</code>方法初始化activity所相关的各种信息，像activity信息、window信息等等，其中有几个重要的在加载插件就初始化的变量需要重新设置。activity初始化之后，就会进入activity生命周期，而相关的方法还是在<code>Instrumentation</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Intent intent = activity.getIntent();</span><br><span class="line">    <span class="keyword">if</span> (PluginUtil.isIntentFromPlugin(intent)) &#123;</span><br><span class="line">        Context base = activity.getBaseContext();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LoadedPlugin plugin = <span class="keyword">this</span>.mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">            ReflectUtil.setField(base.getClass(), base, <span class="string">"mResources"</span>, plugin.getResources());</span><br><span class="line">            ReflectUtil.setField(ContextWrapper.class, activity, <span class="string">"mBase"</span>, plugin.getPluginContext());</span><br><span class="line">            ReflectUtil.setField(Activity.class, activity, <span class="string">"mApplication"</span>, plugin.getApplication());</span><br><span class="line">            ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, <span class="string">"mBase"</span>, plugin.getPluginContext());</span><br><span class="line">            <span class="comment">// set screenOrientation</span></span><br><span class="line">            ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent));</span><br><span class="line">            <span class="keyword">if</span> (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123;</span><br><span class="line">                activity.setRequestedOrientation(activityInfo.screenOrientation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mBase.callActivityOnCreate(activity, icicle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callActivityOnCreate</code>方法就是去回调<code>activity</code>的<code>OnCreate</code>方法，因此重写该方法设置必要的变量是一个首选的位置。主要设置了activity的三个变量，<code>mResources</code>、<code>mBase</code>、<code>mApplication</code>，<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>中自定义了一个<code>ContextWrapper</code>类，并重写了其中几个比较重要的方法，返回<code>LoadedPlugin</code>中提前定义好的变量。到此为止，整个activity启动过程就完美结束了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>插件中activity启动需要熟悉activity启动流程，在里面找到合适的位置去“偷梁换柱”，<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>的实现算是比较简洁的，基本上所有的替换工作都是在<code>Instrumentation</code>中进行，未涉及到<code>AMS</code>的hook，这也就出现了不同的插件化实现方法。除了上面分析的，<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>中还自定义实现了几个比较重要的类，以及上一篇<a href="https://ymlion.com/post/virtualapk-analysis-1/">加载</a>中所提前做的准备，整个的这些才是实现的全部。</p><blockquote><p>本篇文章基于<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a> 0.9.3版本</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;启动activity是在插件化中是最为复杂的，既有启动模式的多样性，又有生命周期的多变性，更是涉及到资源加载。启动一个插件中的activity，难点在于该activity没有在宿主中注册，直接启动肯定没法找到这个activity。如何解决，需要对activity启动流程比较熟悉。activity启动流程过于复杂，涉及类也众多，但主要需要关注的有&lt;code&gt;Activity&lt;/code&gt;、&lt;code&gt;Instrumentation&lt;/code&gt;、&lt;code&gt;AMS&lt;/code&gt;、&lt;code&gt;ActivityThread&lt;/code&gt;这4个类。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="VirtualAPK" scheme="https://ymlion.com/tags/VirtualAPK/"/>
    
  </entry>
  
  <entry>
    <title>Android ClassLoader分析</title>
    <link href="https://ymlion.com/post/android-classloader/"/>
    <id>https://ymlion.com/post/android-classloader/</id>
    <published>2018-03-07T13:40:08.000Z</published>
    <updated>2018-04-08T03:49:49.978Z</updated>
    
    <content type="html"><![CDATA[<p>类加载器的作用就是把程序或系统中用到的类加载到JVM虚拟机中，让程序或系统运行起来。android中的类加载器和纯java环境的类加载器是不同的，android中有自己的三个类加载器。<code>ClassLoader</code>是抽象类，定义了类加载器的功能方法，所有的类加载器都继承自<code>ClassLoader</code>，android中的三个类加载器是<code>BootClassLoader</code>、<code>PathClassLoader</code>、<code>DexClassLoader</code>，继承关系如下：</p><img src="/post/android-classloader/classloader-classes.png" title="Android ClassLoader类图"><a id="more"></a><h2 id="类加载器加载逻辑"><a href="#类加载器加载逻辑" class="headerlink" title="类加载器加载逻辑"></a>类加载器加载逻辑</h2><p>Java类加载逻辑是双亲委托模型，双亲委托简单来解释下就是当加载类时，当前的<code>classLoader</code>先去检查该类是否加载过，若没有加载则委托给父类加载器去加载，重复前面的逻辑直到找到该类或者父类加载器为空的祖宗类加载器，此时若还没找到该类，则去当前类加载器的类库路径去找，若没有则返回给其子类加载器，直到在某个路径下找到该类。</p><blockquote><p>父类加载器是指<code>ClassLoader</code>中parent变量对应的<code>ClassLoader</code>实例。</p></blockquote><p>虽然比较简单，但是<code>Talk is cheap. Show me the code</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是代码直白易懂！也能看出双亲委托的好处：避免重复加载及更加安全。</p><h2 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h2><p><code>BootClassLoader</code>是<code>ClassLoader</code>的内部类，该类的实例是单例模式，没法在外部调用，正常情况下也不会使用到这个类。但该类是android中所有<code>ClassLoader</code>实例的父类加载器，在系统启动的时候就已经完成了初始化。在前面的<a href="http://ymlion.com/2017/12/07/zygote-analysis/">Zygote进程分析</a>中说到<code>Zygote</code>进程首先就预加载了公共类和资源，其中加载公共类中的<code>preloadClasses</code>就对<code>BootClassLoader</code>进行了初始化，就一行代码<code>Class.forName(line, true, null)</code>，下面看下这个方法的具体逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;<span class="comment">// 就是这个地方了</span></span><br><span class="line">        loader = BootClassLoader.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = classForName(name, initialize, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> LinkageError) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (LinkageError) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>loader</code>每次都是空的，<code>BootClassLoader</code>就生成一个单例实例，也就是说<code>BootClassLoader</code>是用来加载系统常用类。</p><h2 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h2><p>android默认使用<code>PathClassLoader</code>来加载系统类和应用程序中的类，该类加载器只是对<code>BaseDexClass</code>类的简单封装，只提供了构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意第二个参数为null，这也是和DexClassLoader的唯一区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意第二个参数为null，这也是和DexClassLoader的唯一区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android系统中的<code>PathClassLoader</code>实例初始化是很早的，因为其作用很重要，同样回到<code>ZygoteInit</code>中，在<code>Zygote</code>创建完<code>SystemServer</code>之后调用<code>handleSystemServerProcess</code>方法处理后续工作，在该方法中有几行代码就是来创建<code>PathClassLoader</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;<span class="comment">// 在这里创建系统的PathClassLoader</span></span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Pass the remaining arguments to SystemServer.主要看这个方法，正常systemserver执行的地方</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> PathClassLoader <span class="title">createPathClassLoader</span><span class="params">(String classPath, <span class="keyword">int</span> targetSdkVersion)</span> </span>&#123;</span><br><span class="line">  String libraryPath = System.getProperty(<span class="string">"java.library.path"</span>);</span><br><span class="line">  <span class="keyword">return</span> PathClassLoaderFactory.createClassLoader(classPath,</span><br><span class="line">                                                  libraryPath,</span><br><span class="line">                                                  libraryPath,</span><br><span class="line">                                                  ClassLoader.getSystemClassLoader(),</span><br><span class="line">                                                  targetSdkVersion,</span><br><span class="line">                                                  <span class="keyword">true</span> <span class="comment">/* isNamespaceShared */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>PathClassLoaderFactory.createClassLoader</code>方法中就直接<code>new</code>了一个<code>PathClassLoader</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(dexPath, librarySearchPath, parent);</span><br></pre></td></tr></table></figure><p>这里关注下第三个参数<code>parent</code>，就是前面传递过来的<code>ClassLoader.getSystemClassLoader()</code>，这个方法最终调用<code>ClassLoader.createSystemClassLoader</code>方法来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String classPath = System.getProperty(<span class="string">"java.class.path"</span>, <span class="string">"."</span>);</span><br><span class="line">    String librarySearchPath = System.getProperty(<span class="string">"java.library.path"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出这个地方相当于创建了两个<code>PathClassLoader</code>实例，后者是前者的父类加载器，后者的父类加载器是<code>Zygote</code>预加载时创建的<code>BootClassLoader</code>对象。</p><h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p><code>DexClassLoader</code>主要用于加载第三方dex或者包含dex的jar、apk文件，这也是插件化或者热修复中用到最多的类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数是一个非null文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出<code>DexClassLoader</code>和<code>PathClassLoader</code>都比较简单，只提供了简单的构造方法用于区分，最主要的实现还是在<code>BaseDexClassLoader</code>中， 上面的参数以及android类加载器具体实现下面再细说。</p><h2 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 这里已经不需要optimizedDirectory这个参数了</span></span><br><span class="line">    <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reporter.report(<span class="keyword">this</span>.pathList.getDexPaths());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是构造方法，先来看下前三个参数：</p><ul><li><code>dexPath</code>：jar/apk文件列表，用<code>:</code>分割；</li><li><code>optimizedDirectory</code>：dex解压之后存放目录，必须是内部存储目录，这个也是<code>DexClassLoader</code>和<code>PathClassLoader</code>唯一不同的一个参数，在<code>SDK26</code>的源码中上面的注释已经说了这个参数<strong>完全没用</strong>了，也就是说两者没有区别了；</li><li><code>librarySearchPath</code>：包含本地库的文件夹列表，用<code>:</code>分割。</li></ul><p>这几个参数主要用于初始化成员变量<code>DexPathList</code>对象<code>pathList</code>，该对象保存了所有的dex文件相关信息，大部分逻辑也是和该对象有关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(</span><br><span class="line">                <span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载器的主要实现就是<code>findClass</code>方法，可以看到是<code>pathList</code>对象去调用其<code>findClass</code>方法，最终在native层实现，这里就不深究了。看到<code>findClass</code>方法的实现，我们也能想到如何合并dex，例如合并插件的<code>classLoader</code>，这里的重点就是<code>pathList</code>对象，通过反射将不同的<code>pathList</code>合并为一个，就是合并该对象中的dex列表。</p><h2 id="PathClassLoader和DexClassLoader区别"><a href="#PathClassLoader和DexClassLoader区别" class="headerlink" title="PathClassLoader和DexClassLoader区别"></a>PathClassLoader和DexClassLoader区别</h2><p>前面也说了，区别就是构造方法的第二个参数，即有没有自定义一个内部文件夹来保存解压后的dex。看上面的源码已经发现至少在android8.0上，该参数没有作用，即两者效果一样。那原来的区别到底是什么呢？这里看下android4.4的源码，在<code>DexFile</code>对应的本地实现<code>art/runtime/native/dalvik_system_DexFile.cc</code>中的<code>openDexFileNative</code>方法中有这么几行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (outputName.c_str() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    dex_file = linker-&gt;FindDexFileInOatFileFromDexLocation(dex_location, dex_location_checksum);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> oat_location(outputName.c_str());</span><br><span class="line">    dex_file = linker-&gt;FindOrCreateOatFileForDexLocation(dex_location, dex_location_checksum, oat_location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>outputName.c_str()</code>就是上面<code>optimizedDirectory</code>路径，在这里有了区分。下面看下<code>art/runtime/class_linker.cc</code>类，分别找到对应的两个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DexFile* ClassLinker::FindDexFileInOatFileFromDexLocation(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dex_location,</span><br><span class="line">                                                                <span class="keyword">uint32_t</span> dex_location_checksum) &#123;</span><br><span class="line">  <span class="comment">// 该方法省略了很多</span></span><br><span class="line">  <span class="comment">// Look for an existing file in the dalvik-cache, validating the result if found</span></span><br><span class="line">  <span class="comment">// not found in /foo/bar/baz.odex? try /data/dalvik-cache/foo@bar@baz.jar@classes.dex</span></span><br><span class="line">  std::string cache_location(GetDalvikCacheFilenameOrDie(dex_location));</span><br><span class="line">  oat_file.reset(FindOatFileFromOatLocationLocked(cache_location));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to generate oat file if it wasn't found or was obsolete.</span></span><br><span class="line">  std::string oat_cache_filename(GetDalvikCacheFilenameOrDie(dex_location));</span><br><span class="line">  <span class="keyword">return</span> FindOrCreateOatFileForDexLocationLocked(dex_location, dex_location_checksum, oat_cache_filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DexFile* ClassLinker::FindOrCreateOatFileForDexLocation(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dex_location,</span><br><span class="line">                                                              <span class="keyword">uint32_t</span> dex_location_checksum,</span><br><span class="line">                                                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; oat_location) &#123;</span><br><span class="line">  WriterMutexLock mu(Thread::Current(), dex_lock_);</span><br><span class="line">  <span class="keyword">return</span> FindOrCreateOatFileForDexLocationLocked(dex_location, dex_location_checksum, oat_location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比上面两个方法，可以发现最终都调用同样一个方法，区别就是当<code>optimizedDirectory</code>为<code>null</code>时，需要去生成这个目录，这个目录就是<code>/data/dalvik-cache/</code>。</p><p>至此，<code>PathClassLoader</code>和<code>DexClassLoader</code>的区别也就明了了，就是<code>PathClassLoader</code>只能加载系统安装过的apk，其dex保存在<code>/data/dalvik-cache</code>中；而<code>DexClassLoader</code>可以去加载外部存储中存在的jar/apk文件。</p><p>经过测试以及源码研究，发现在android5.0以下是有这个区别的，其他就是像上面构造方法显示的一样，<strong>就结果来说两者没有区别</strong>。具体android5.0–7.1的源码没有仔细研究，每个版本都不相同，变化差异很大，以上是在模拟器上测试得出的结论。两者的区别是一个比较重要的知识点，现在应该比较清晰了。</p><blockquote><p>在<strong>模拟器</strong>上测试发现，android8.0之后，<code>PathClassLoader</code>和<code>DexClassLoader</code><strong>加载外部存储器</strong>上的jar/apk文件会<strong>崩溃</strong>，因此只能copy到内部存储器中去加载。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>类加载的双亲委托模型是一个很好的设计，值得我们学习和思考。android系统的类加载器都有各自的分工：</p><ul><li><code>BootClassLoader</code>：系统启动时加载公共类，并作为所有<code>ClassLoader</code>的<code>parent</code>；</li><li><code>PathClassLoader</code>：<code>SystemServer</code>启动后去创建，用于加载系统类及程序类；同样可以加载插件；</li><li><code>DexClassLoader</code>：用于加载插件，在<code>android5.0</code>及其以后与<code>PathClassLoader</code>没有区别。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类加载器的作用就是把程序或系统中用到的类加载到JVM虚拟机中，让程序或系统运行起来。android中的类加载器和纯java环境的类加载器是不同的，android中有自己的三个类加载器。&lt;code&gt;ClassLoader&lt;/code&gt;是抽象类，定义了类加载器的功能方法，所有的类加载器都继承自&lt;code&gt;ClassLoader&lt;/code&gt;，android中的三个类加载器是&lt;code&gt;BootClassLoader&lt;/code&gt;、&lt;code&gt;PathClassLoader&lt;/code&gt;、&lt;code&gt;DexClassLoader&lt;/code&gt;，继承关系如下：&lt;/p&gt;
&lt;img src=&quot;/post/android-classloader/classloader-classes.png&quot; title=&quot;Android ClassLoader类图&quot;&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="ClassLoader" scheme="https://ymlion.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>VirtualAPK加载分析</title>
    <link href="https://ymlion.com/post/virtualapk-analysis-1/"/>
    <id>https://ymlion.com/post/virtualapk-analysis-1/</id>
    <published>2018-03-06T09:04:01.000Z</published>
    <updated>2018-04-08T03:49:50.089Z</updated>
    
    <content type="html"><![CDATA[<p>使用<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a>加载插件时，在应用启动时要去初始化，并在该加载插件的时候去加载插件，这两步大部分情况下并不是一起执行的，因为第一步正常情况下在<code>Application.onCreate</code>中就执行了，下面简单看下在这两步中都做了什么。</p><a id="more"></a><h3 id="PluginManager初始化"><a href="#PluginManager初始化" class="headerlink" title="PluginManager初始化"></a><code>PluginManager</code>初始化</h3><ol><li>创建<code>PluginManager</code>，将<code>application context</code>保存到<code>mContext</code>；</li><li>hook掉<code>ActivityThread</code>中的<code>Instrumention</code>和<code>Handler</code>对象<code>mInstrumentation</code>和<code>mH</code>的<code>Callback</code>；</li><li>hook掉<code>AMS</code>， <code>API26</code>和其以下源码不同，分别hook，使用动态代理以<code>ActivityManagerProxy</code>来拦截<code>AMS</code>中的某些方法，大部分是和<code>Service</code>相关的；</li><li>执行<code>init</code>方法，该方法暂时只创建<code>mComponentsHandler</code>对象，第二步执行的后台方法为空方法。</li></ol><h3 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h3><p>这是加载插件的过程，通过<code>PluginManager.loadPlugin</code>来执行这个过程，代码很简单，其中最主要的就是解析插件文件构造<code>LoadedPlugin</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPlugin</span><span class="params">(File apk)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LoadedPlugin plugin = LoadedPlugin.create(<span class="keyword">this</span>, <span class="keyword">this</span>.mContext, apk);<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != plugin) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mPlugins.put(plugin.getPackageName(), plugin);<span class="comment">// 2</span></span><br><span class="line">        plugin.invokeApplication();<span class="comment">// 3</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">"Can't load plugin which is invalid: "</span> + apk.getAbsolutePath());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建LoadedPlugin实例"><a href="#创建LoadedPlugin实例" class="headerlink" title="创建LoadedPlugin实例"></a>创建<code>LoadedPlugin</code>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">LoadedPlugin(PluginManager pluginManager, Context context, File apk) <span class="keyword">throws</span> PackageParser.PackageParserException &#123;</span><br><span class="line">    <span class="keyword">this</span>.mPluginManager = pluginManager;</span><br><span class="line">    <span class="keyword">this</span>.mHostContext = context;</span><br><span class="line">    <span class="keyword">this</span>.mLocation = apk.getAbsolutePath();</span><br><span class="line">    <span class="keyword">this</span>.mPackage = PackageParserCompat.parsePackage(context, apk, PackageParser.PARSE_MUST_BE_APK);</span><br><span class="line">    <span class="keyword">this</span>.mPackage.applicationInfo.metaData = <span class="keyword">this</span>.mPackage.mAppMetaData;</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo = <span class="keyword">new</span> PackageInfo();</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.applicationInfo = <span class="keyword">this</span>.mPackage.applicationInfo;</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.applicationInfo.sourceDir = apk.getAbsolutePath();</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.signatures = <span class="keyword">this</span>.mPackage.mSignatures;</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.packageName = <span class="keyword">this</span>.mPackage.packageName;</span><br><span class="line">    <span class="keyword">if</span> (pluginManager.getLoadedPlugin(mPackageInfo.packageName) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"plugin has already been loaded : "</span> + mPackageInfo.packageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.versionCode = <span class="keyword">this</span>.mPackage.mVersionCode;</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.versionName = <span class="keyword">this</span>.mPackage.mVersionName;</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.permissions = <span class="keyword">new</span> PermissionInfo[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.mPackageManager = <span class="keyword">new</span> PluginPackageManager();</span><br><span class="line">    <span class="keyword">this</span>.mPluginContext = <span class="keyword">new</span> PluginContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.mNativeLibDir = context.getDir(Constants.NATIVE_DIR, Context.MODE_PRIVATE);</span><br><span class="line">    <span class="keyword">this</span>.mResources = createResources(context, apk);</span><br><span class="line">    <span class="keyword">this</span>.mClassLoader = createClassLoader(context, apk, <span class="keyword">this</span>.mNativeLibDir, context.getClassLoader());</span><br><span class="line">    tryToCopyNativeLib(apk);</span><br><span class="line">    <span class="comment">// Cache instrumentations</span></span><br><span class="line">    Map&lt;ComponentName, InstrumentationInfo&gt; instrumentations = <span class="keyword">new</span> HashMap&lt;ComponentName, InstrumentationInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PackageParser.Instrumentation instrumentation : <span class="keyword">this</span>.mPackage.instrumentation) &#123;</span><br><span class="line">        instrumentations.put(instrumentation.getComponentName(), instrumentation.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mInstrumentationInfos = Collections.unmodifiableMap(instrumentations);</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.instrumentation = instrumentations.values().toArray(<span class="keyword">new</span> InstrumentationInfo[instrumentations.size()]);</span><br><span class="line">    <span class="comment">// Cache activities</span></span><br><span class="line">    Map&lt;ComponentName, ActivityInfo&gt; activityInfos = <span class="keyword">new</span> HashMap&lt;ComponentName, ActivityInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PackageParser.Activity activity : <span class="keyword">this</span>.mPackage.activities) &#123;</span><br><span class="line">        activityInfos.put(activity.getComponentName(), activity.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mActivityInfos = Collections.unmodifiableMap(activityInfos);</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.activities = activityInfos.values().toArray(<span class="keyword">new</span> ActivityInfo[activityInfos.size()]);</span><br><span class="line">    <span class="comment">// Cache services</span></span><br><span class="line">    Map&lt;ComponentName, ServiceInfo&gt; serviceInfos = <span class="keyword">new</span> HashMap&lt;ComponentName, ServiceInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PackageParser.Service service : <span class="keyword">this</span>.mPackage.services) &#123;</span><br><span class="line">        serviceInfos.put(service.getComponentName(), service.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mServiceInfos = Collections.unmodifiableMap(serviceInfos);</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.services = serviceInfos.values().toArray(<span class="keyword">new</span> ServiceInfo[serviceInfos.size()])</span><br><span class="line">    <span class="comment">// Cache providers</span></span><br><span class="line">    Map&lt;String, ProviderInfo&gt; providers = <span class="keyword">new</span> HashMap&lt;String, ProviderInfo&gt;();</span><br><span class="line">    Map&lt;ComponentName, ProviderInfo&gt; providerInfos = <span class="keyword">new</span> HashMap&lt;ComponentName, ProviderInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PackageParser.Provider provider : <span class="keyword">this</span>.mPackage.providers) &#123;</span><br><span class="line">        providers.put(provider.info.authority, provider.info);</span><br><span class="line">        providerInfos.put(provider.getComponentName(), provider.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mProviders = Collections.unmodifiableMap(providers);</span><br><span class="line">    <span class="keyword">this</span>.mProviderInfos = Collections.unmodifiableMap(providerInfos);</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.providers = providerInfos.values().toArray(<span class="keyword">new</span> ProviderInfo[providerInfos.size()]);</span><br><span class="line">    <span class="comment">// Register broadcast receivers dynamically</span></span><br><span class="line">    Map&lt;ComponentName, ActivityInfo&gt; receivers = <span class="keyword">new</span> HashMap&lt;ComponentName, ActivityInfo&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PackageParser.Activity receiver : <span class="keyword">this</span>.mPackage.receivers) &#123;</span><br><span class="line">        receivers.put(receiver.getComponentName(), receiver.info);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());</span><br><span class="line">            <span class="keyword">for</span> (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mHostContext.registerReceiver(br, aii);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mReceiverInfos = Collections.unmodifiableMap(receivers);</span><br><span class="line">    <span class="keyword">this</span>.mPackageInfo.receivers = receivers.values().toArray(<span class="keyword">new</span> ActivityInfo[receivers.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码比较长，要做的事情也比较多，一步一步来分析。</p><ol><li><p>保存传过来的几个参数到成员变量，尤其是<code>pluginManager</code>和<code>context</code>，后面用到的比较频繁；</p></li><li><p>通过<code>PackageParserCompat.parsePackage</code>来解析插件apk，由于版本变化比较大，因此分为24、21及21以下三个来分别解析。解析方法使用SDK中隐藏类<code>android.content.pm.PackageParse</code>中的<code>parsePackage</code>方法，最终该方法返回<code>PackageParse.Package</code>类实例，该类包含了解析的apk文件的所有信息即<code>AndroidManifest.xml</code>中包含的信息及其他信息。这一步至关重要，是所有后面操作的基础。</p></li><li><p>根据解析之后得到的<code>mPackage</code>，创建了<code>PackageInfo</code>实例<code>mPackageInfo</code>；并赋值之后的几个成员变量；</p></li><li><p>获取插件的<code>Resources</code>对象，这里根据是否合并宿主和插件的资源分成两种不同的获取方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Resources <span class="title">createResources</span><span class="params">(Context context, File apk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.COMBINE_RESOURCES) &#123; <span class="comment">// 合并资源，该值为true</span></span><br><span class="line">        Resources resources = ResourcesManager.createResources(context, apk.getAbsolutePath());</span><br><span class="line">        ResourcesManager.hookResources(context, resources);</span><br><span class="line">        <span class="keyword">return</span> resources;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不合并，生成新的Resources</span></span><br><span class="line">        Resources hostResources = context.getResources();</span><br><span class="line">        AssetManager assetManager = createAssetManager(context, apk);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说不合并，这个比较简单，创建<code>AssetManager</code>对象，通过反射<code>AssetManager.addAssetPath</code>将插件资源添加到<code>AssetManager</code>对象中，最后<code>new</code>一个<code>Resources</code>对象即可，该对象即可方法插件资源。</p><p>如果要合并资源，就是获取到宿主的<code>AssetManager</code>实例，并通过<code>addAssetPath</code>把每个插件添加到该实例中，再<code>new</code>一个新的<code>Resources</code>对象，并更新每个插件的<code>Resources</code>对象，看下具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Resources <span class="title">createResources</span><span class="params">(Context hostContext, String apk)</span> </span>&#123;</span><br><span class="line">    Resources hostResources = hostContext.getResources();</span><br><span class="line">    Resources newResources = <span class="keyword">null</span>;</span><br><span class="line">    AssetManager assetManager;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;<span class="comment">// 添加宿主资源</span></span><br><span class="line">            assetManager = AssetManager.class.newInstance();</span><br><span class="line">            ReflectUtil.invoke(AssetManager.class, assetManager, <span class="string">"addAssetPath"</span>, hostContext.getApplicationInfo().sourceDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 直接获取宿主的AssetManager对象</span></span><br><span class="line">            assetManager = hostResources.getAssets();</span><br><span class="line">        &#125;</span><br><span class="line">        ReflectUtil.invoke(AssetManager.class, assetManager, <span class="string">"addAssetPath"</span>, apk);</span><br><span class="line">        List&lt;LoadedPlugin&gt; pluginList = PluginManager.getInstance(hostContext).getAllLoadedPlugins();</span><br><span class="line">        <span class="keyword">for</span> (LoadedPlugin plugin : pluginList) &#123; <span class="comment">// 添加每个插件的资源</span></span><br><span class="line">            ReflectUtil.invoke(AssetManager.class, assetManager, <span class="string">"addAssetPath"</span>, plugin.getLocation());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于厂商乱改问题，分别对不同厂商机型进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (isMiUi(hostResources)) &#123;</span><br><span class="line">            newResources = MiUiResourcesCompat.createResources(hostResources, assetManager);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVivo(hostResources)) &#123;</span><br><span class="line">            newResources = VivoResourcesCompat.createResources(hostContext, hostResources, assetManager);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNubia(hostResources)) &#123;</span><br><span class="line">            newResources = NubiaResourcesCompat.createResources(hostResources, assetManager);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNotRawResources(hostResources)) &#123;</span><br><span class="line">            newResources = AdaptationResourcesCompat.createResources(hostResources, assetManager);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// is raw android resources</span></span><br><span class="line">            newResources = <span class="keyword">new</span> Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lastly, sync all LoadedPlugin to newResources</span></span><br><span class="line">        <span class="keyword">for</span> (LoadedPlugin plugin : pluginList) &#123;</span><br><span class="line">            plugin.updateResources(newResources);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newResources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>DexClassLoader</code>来加载外部存储中的插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(Context context, File apk, File libsDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    File dexOutputDir = context.getDir(Constants.OPTIMIZE_DIR, Context.MODE_PRIVATE);</span><br><span class="line">    String dexOutputPath = dexOutputDir.getAbsolutePath();</span><br><span class="line">    DexClassLoader loader = <span class="keyword">new</span> DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent);</span><br><span class="line">    <span class="keyword">if</span> (Constants.COMBINE_CLASSLOADER) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DexUtil.insertDex(loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法前三行就是标准的加载apk的代码，难点是后面的dex合并，下面是合并的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertDex</span><span class="params">(DexClassLoader dexClassLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前类的PathClassLoader中的pathList变量中的dexElements数组</span></span><br><span class="line">    Object baseDexElements = getDexElements(getPathList(getPathClassLoader()));</span><br><span class="line">    <span class="comment">// 获取dexClassLoader中的pathList变量中的dexElements数组</span></span><br><span class="line">    Object newDexElements = getDexElements(getPathList(dexClassLoader));</span><br><span class="line">    <span class="comment">// 合并两个dexElements，创建一个新的Array对象，保存两者</span></span><br><span class="line">    Object allDexElements = combineArray(baseDexElements, newDexElements);</span><br><span class="line">    Object pathList = getPathList(getPathClassLoader());</span><br><span class="line">    <span class="comment">// 把合并之后的dexElements替换原来PathClassLoader中的pathList变量中的dexElements数组</span></span><br><span class="line">    ReflectUtil.setField(pathList.getClass(), pathList, <span class="string">"dexElements"</span>, allDexElements);</span><br><span class="line">    <span class="comment">// 把native lib文件合并之后替换原来PathClassLoader中的pathList变量中的nativeLibraryDirectories数组</span></span><br><span class="line">    insertNativeLibrary(dexClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android应用中默认加载类的是<code>PathClassLoader</code>，<code>DexClassLoader</code>是加载自定义的jar、dex、apk、zip中的类的，两者都继承自<code>BaseDexClassLoader</code>。将插件dex的路径合并到原始的<code>PathClassLoader</code>对象中，后面加载插件的类，就可以用该对象加载了。</p></li><li><p>使用<code>ZipFile</code>解压apk文件，将其中的<code>.so</code>库复制到<code>mNativeLibDir</code>中；</p></li><li><p>通过<code>mPackage</code>获取所有测试类信息<code>InstrumentationInfo</code>、activity信息<code>ActivityInfo</code>、服务信息<code>ServiceInfo</code>、provider信息<code>ProviderInfo</code>；</p></li><li><p>获取所有的静态广播信息，并动态重新注册。</p></li></ol><p>创建完成<code>LoadedPlugin</code>实例之后，将该对象保存到哈希表中，最后一步是创建<code>LoadedPlugin</code>实例的成员变量<code>mApplication</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.mApplication) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mApplication;</span><br><span class="line">    &#125;</span><br><span class="line">    String appClass = <span class="keyword">this</span>.mPackage.applicationInfo.className;</span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || <span class="keyword">null</span> == appClass) &#123;</span><br><span class="line">        appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mApplication = instrumentation.newApplication(<span class="keyword">this</span>.mClassLoader, appClass, <span class="keyword">this</span>.getPluginContext());</span><br><span class="line">        instrumentation.callApplicationOnCreate(<span class="keyword">this</span>.mApplication);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mApplication;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，就是直接调用<code>Instrumentation.newApplication</code>去创建<code>Application</code>实例，并执行其<code>onCreate</code>方法。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><code>PluginManager</code>的初始化主要工作是hook掉<code>ActivityThread</code>中的<code>Instrumention</code>、<code>AMS</code>和<code>PMS</code>，为后面四大组件能正常运行提供基础；</li><li>加载插件主要是构造<code>LoadedPlugin</code>对象，解析apk文件，获取apk的全部信息，并保存四大组件信息、加载dex、合并资源等。</li></ol><p>这篇主要是分析加载插件中做了什么，至于每一步的具体作用以及加载实现，就放在下一篇去分析。</p><blockquote><p>本篇文章基于<a href="https://github.com/didi/VirtualAPK" target="_blank" rel="noopener">VirtualAPK</a> 0.9.3版本</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;a href=&quot;https://github.com/didi/VirtualAPK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualAPK&lt;/a&gt;加载插件时，在应用启动时要去初始化，并在该加载插件的时候去加载插件，这两步大部分情况下并不是一起执行的，因为第一步正常情况下在&lt;code&gt;Application.onCreate&lt;/code&gt;中就执行了，下面简单看下在这两步中都做了什么。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="插件化" scheme="https://ymlion.com/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="插件化" scheme="https://ymlion.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="VirtualAPK" scheme="https://ymlion.com/tags/VirtualAPK/"/>
    
  </entry>
  
  <entry>
    <title>SystemServer分析</title>
    <link href="https://ymlion.com/post/systemserver/"/>
    <id>https://ymlion.com/post/systemserver/</id>
    <published>2017-12-13T09:12:32.000Z</published>
    <updated>2018-04-08T03:49:50.049Z</updated>
    
    <content type="html"><![CDATA[<p><code>SystemServer</code>是<code>Zygote</code>进程启动之后fork的第一个子进程，所有的系统服务就在该进程中启动，是android系统良好运转的基础，从此开始，就标志着系统正式启动了。</p><a id="more"></a><h2 id="系统服务启动过程概览"><a href="#系统服务启动过程概览" class="headerlink" title="系统服务启动过程概览"></a>系统服务启动过程概览</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// systemserver进程启动之后的入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for factory test mode.</span></span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line">    <span class="comment">// Remember if it's runtime restart(when sys.boot_completed is already set) or reboot</span></span><br><span class="line">    <span class="comment">// 系统启动后会将该属性设置为1，在activitymanagerservice类中</span></span><br><span class="line">    mRuntimeRestart = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">"InitBeforeStartServices"</span>);</span><br><span class="line">        <span class="comment">// 时间必须大于0，这里是一天即86400000ms</span></span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"System clock is before 1970; setting to 1970."</span>);</span><br><span class="line">            SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时区设置，没有则设置为0时区</span></span><br><span class="line">        String timezoneProperty =  SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 语言</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">            SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The system server should never make non-oneway calls</span></span><br><span class="line">        Binder.setWarnOnBlocking(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Here we go!</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Entered the Android system server!"</span>);</span><br><span class="line">        <span class="keyword">int</span> uptimeMillis = (<span class="keyword">int</span>) SystemClock.elapsedRealtime();</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);</span><br><span class="line">        <span class="keyword">if</span> (!mRuntimeRestart) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_system_server_init"</span>, uptimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// In case the runtime switched since last boot (such as when</span></span><br><span class="line">        <span class="comment">// the old runtime was removed in an OTA), set the system</span></span><br><span class="line">        <span class="comment">// property so that it is in sync. We can | xq oqi't do this in</span></span><br><span class="line">        <span class="comment">// libnativehelper's JniInvocation::Init code where we already</span></span><br><span class="line">        <span class="comment">// had to fallback to a different runtime because it is</span></span><br><span class="line">        <span class="comment">// running as root and we need to be the system user to set</span></span><br><span class="line">        <span class="comment">// the property. http://b/11463182</span></span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line">        <span class="comment">// Enable the sampling profiler.</span></span><br><span class="line">        <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">            SamplingProfilerIntegration.start();</span><br><span class="line">            mProfilerSnapshotTimer = <span class="keyword">new</span> Timer();</span><br><span class="line">            mProfilerSnapshotTimer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        SamplingProfilerIntegration.writeSnapshot(<span class="string">"system_server"</span>, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除任何限制，使内存可以分配为最大值</span></span><br><span class="line">        VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">        <span class="comment">// The system server has to run all of the time, so it needs to be</span></span><br><span class="line">        <span class="comment">// as efficient as possible with its memory usage.</span></span><br><span class="line">        <span class="comment">// 设置堆使用率</span></span><br><span class="line">        VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line">        <span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line">        <span class="comment">// we've defined it before booting further.</span></span><br><span class="line">        <span class="comment">// 设置指纹识别</span></span><br><span class="line">        Build.ensureFingerprintProperty();</span><br><span class="line">        <span class="comment">// Within the system server, it is an error to access Environment paths without</span></span><br><span class="line">        <span class="comment">// explicitly specifying a user.</span></span><br><span class="line">        Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Within the system server, any incoming Bundles should be defused</span></span><br><span class="line">        <span class="comment">// to avoid throwing BadParcelableException.</span></span><br><span class="line">        BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">        <span class="comment">// binder的调用必须是前台优先级</span></span><br><span class="line">        BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// Increase the number of binder threads in system_server</span></span><br><span class="line">        BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line">        <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">        <span class="comment">// 设置当前线程的优先级</span></span><br><span class="line">        android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">        android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">        Looper.prepareMainLooper(); <span class="comment">// 初始化main looper</span></span><br><span class="line">        <span class="comment">// 加载libandroid_servers.so，即系统服务相关的本地方法库</span></span><br><span class="line">        System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line">        <span class="comment">// Check whether we failed to shut down last time we tried.</span></span><br><span class="line">        <span class="comment">// This call may not return.</span></span><br><span class="line">        performPendingShutdown();</span><br><span class="line">        <span class="comment">// 初始化系统上下文</span></span><br><span class="line">        createSystemContext();</span><br><span class="line">        <span class="comment">// 创建系统服务管理器，用于管理系统服务的创建、启动以及其他生命周期</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartServices"</span>);</span><br><span class="line">        <span class="comment">// 启动各类服务，分为三类，重要性依次降低</span></span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">// 线程死循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">// 主线程一直在上面的死循环中，不会执行该步，除非异常退出</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动各类服务之前，先进行了一些初始化及配置：</p><ul><li>系统基本属性的设置，包括时间、时区、语言；</li><li>设置内存大小及使用率，系统服务是随着android系统一直运行的，所以尽可能分配多的内存和高的使用率；</li><li>如果有指纹识别模块，则把指纹识别相关属性初始化了；</li><li>设置binder进入的调用优先级为前台，并把binder线程最大值设置为31；</li><li>初始化main looper；</li><li>加载.so库<code>libandroid_server.so</code>，后面所有系统服务相关的本地方法库；</li><li>初始化系统上下文；</li><li>创建<code>SystemServiceManager</code>。</li></ul><p>然后就是启动系统服务了，根据重要性分三类依次启动，除了重要性外，前面某些服务是后面服务的前提：</p><ul><li>系统引导服务</li><li>系统核心服务</li><li>其他服务</li></ul><p>最后进入死循环，通过android消息机制处理各种消息。整个过程理清楚后，依次看下某些重要部分的具体代码。</p><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>android是消息驱动型系统，进程最终还是要处理消息的，通过两行代码完成了整个消息机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepareMainLooper();</span><br><span class="line">Looper.loop();</span><br></pre></td></tr></table></figure><p>这是主线程创建<code>looper</code>的代码，如果是子线程则有所区别。整个消息处理机制涉及了<code>Handler</code>、<code>MessageQueue</code>、<code>Looper</code>和<code>Message</code>，简单来说<code>Message</code>为消息载体，<code>Handler</code>将消息发送出去，保存到<code>MessageQueue</code>待处理队列中，<code>Looper</code>轮询队列获取待处理消息，交由<code>Handler</code>处理消息，具体细节还是比较多的，这里就不展开了。</p><h2 id="本地动态库"><a href="#本地动态库" class="headerlink" title="本地动态库"></a>本地动态库</h2><p>加载<code>/system/lib/libandroid_servers.so</code>动态库，该库的源代码位于<code>/frameworks/base/services/core/jni</code>目录下，包含了在<code>systemserver</code>中启动的服务的本地方法。简单说下这个<code>libandroid_servers.so</code>是怎么编译出来的，众所周知android系统是用<code>makefile</code>来构建的，主要就是<code>Android.mk</code>文件，整个系统源代码中，<code>Android.mk</code>随处可见。通过查找源代码，发现该.so库是在<code>/frameworks/base/services/Android.mk</code>中：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># native library</span></span><br><span class="line"><span class="comment"># =============================================================</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span> <span class="comment"># 清理大部分LOCAL变量，一个新模块开始</span></span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES :=</span><br><span class="line">LOCAL_SHARED_LIBRARIES :=</span><br><span class="line"></span><br><span class="line"><span class="comment"># include all the jni subdirs to collect their sources</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LOCAL_PATH)</span>/*/jni/Android.mk)</span> <span class="comment"># 该库包含的文件</span></span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS += -DEGL_EGLEXT_PROTOTYPES -DGL_GLEXT_PROTOTYPES</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE:= libandroid_servers <span class="comment"># 库名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span> <span class="comment"># 动态共享库，模块结束</span></span><br></pre></td></tr></table></figure><blockquote><p>了解<code>Android.mk</code>可以去<a href="android.mk">官网</a>和<a href="https://developer.android.com/ndk/guides/android_mk.html" target="_blank" rel="noopener">开发网站</a>。</p></blockquote><h2 id="系统上下文"><a href="#系统上下文" class="headerlink" title="系统上下文"></a>系统上下文</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line">    mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">    <span class="keyword">final</span> Context systemUiContext = activityThread.getSystemUiContext();</span><br><span class="line">    systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActivityThread</code>是应用进程的入口类，确定了应用程序的主线程，并创建了应用进程的消息机制。但在这里，还是有所区别，和main方法中执行相同的是创建了<code>ActivityThread</code>实例，并执行了<code>attach</code>方法，但参数是<code>true</code>，所以在方法内部的逻辑有所不同，下面是<code>attach(true)</code>的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</span><br><span class="line">            UserHandle.myUserId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation(); <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 初始化context</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">        <span class="comment">// 初始化application</span></span><br><span class="line">        mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        mInitialApplication.onCreate();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     ......</span><br><span class="line">     <span class="comment">// 后面设置了系统属性变化时的回调</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>ActivityThread</code>获取到<code>context</code>之后，就分别设置了默认主题。</p><h2 id="引导服务"><a href="#引导服务" class="headerlink" title="引导服务"></a>引导服务</h2><p>在创建<code>SystemServiceManager</code>实例之后，就开始启动各类系统服务了，首先就是系统引导服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读写系统配置</span></span><br><span class="line">    SystemServerInitThreadPool.get().submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG);</span><br><span class="line">    <span class="comment">// 启动installer</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line">    <span class="comment">// 部分应用会使用设备id，所以在activitymanager之前注册</span></span><br><span class="line">    mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);</span><br><span class="line">    <span class="comment">// Activity manager出场，activity、process的创建在这里开始</span></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    <span class="comment">// 电源管理服务，很多服务依赖该服务，并初始化</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    <span class="comment">// Bring up recovery system in case a rescue party needs a reboot</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemProperties.getBoolean(<span class="string">"config.disable_noncore"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        mSystemServiceManager.startService(RecoverySystemService.class);</span><br><span class="line">    &#125;</span><br><span class="line">    RescueParty.noteBoot(mSystemContext);</span><br><span class="line">    <span class="comment">// LED灯管理服务</span></span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">    <span class="comment">// 显示服务</span></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line">    <span class="comment">// We need the default display before we can initialize the package manager.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">// Only run "core" apps if we're encrypting the device.</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动包管理服务.</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    <span class="comment">// Manages A/B OTA dexopting. This is a bootstrap service as we need it to rename</span></span><br><span class="line">    <span class="comment">// A/B artifacts after boot, before anything else might touch/need them.</span></span><br><span class="line">    <span class="comment">// Note: this isn't needed during decryption (we don't have /data anyways).</span></span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">"config.disable_otadexopt"</span>,</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!disableOtaDexopt) &#123;<span class="comment">// ota服务</span></span><br><span class="line">            OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户管理服务</span></span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);</span><br><span class="line">    <span class="comment">// Initialize attribute cache used to cache resources from packages.</span></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line">    <span class="comment">// 注册binder服务，获取application信息，保存process信息</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">    <span class="comment">// DisplayManagerService needs to setup android.display scheduling related policies</span></span><br><span class="line">    <span class="comment">// since setSystemProcess() would have overridden policies due to setProcessGroup</span></span><br><span class="line">    mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line">    <span class="comment">// Manages Overlay packages</span></span><br><span class="line">    mSystemServiceManager.startService(<span class="keyword">new</span> OverlayManagerService(mSystemContext, installer));</span><br><span class="line">    <span class="comment">// The sensor service needs access to package manager service, app ops</span></span><br><span class="line">    <span class="comment">// service, and permissions service, therefore we start it after them.</span></span><br><span class="line">    <span class="comment">// Start sensor service in a separate thread. Completion should be checked</span></span><br><span class="line">    <span class="comment">// before using it.</span></span><br><span class="line">    <span class="comment">// 传感器相关服务启动，native层方法启动</span></span><br><span class="line">    mSensorServiceStart = SystemServerInitThreadPool.get().submit(() -&gt; &#123;</span><br><span class="line">        BootTimingsTraceLog traceLog = <span class="keyword">new</span> BootTimingsTraceLog(</span><br><span class="line">                SYSTEM_SERVER_TIMING_ASYNC_TAG, Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">        startSensorService();</span><br><span class="line">    &#125;, START_SENSOR_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心服务"><a href="#核心服务" class="headerlink" title="核心服务"></a>核心服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动系统基础服务，这些服务并没有和引导服务纠缠在一起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 系统关键日志服务</span></span><br><span class="line">    mSystemServiceManager.startService(DropBoxManagerService.class);</span><br><span class="line">    <span class="comment">// 电池服务：监控充电状态及电量变化，发送电池变化广播。  Requires LightService.</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line">    <span class="comment">// 应用使用统计服务</span></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line">    <span class="comment">// webview更新服务</span></span><br><span class="line">    mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h2><p>这部分服务就太多了，包括键盘、电话、输入法、网络、相机等相关服务、帐号、窗口、蓝牙、无障碍、存储、通知、位置、搜索等管理服务，这里就不一一例举了，基本能想到的、系统中使用到的基本都在这里了。在启动完各个服务之后，也就意味着系统准备好启动其他进程了，所以在<code>startOtherServices()</code>的最后就开始启动其他进程以及进行一些服务的后续工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vibrator.systemReady();</span><br><span class="line">lockSettings.systemReady();</span><br><span class="line">mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">wm.systemReady();</span><br><span class="line"><span class="comment">// Update the configuration for this context by hand, because we're going</span></span><br><span class="line"><span class="comment">// to start using it before the config change done in wm.systemReady() will</span></span><br><span class="line"><span class="comment">// propagate to it.</span></span><br><span class="line"><span class="keyword">final</span> Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY);</span><br><span class="line">DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">WindowManager w = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">w.getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">context.getResources().updateConfiguration(config, metrics);</span><br><span class="line"><span class="comment">// The system context's theme may be configuration-dependent.</span></span><br><span class="line"><span class="keyword">final</span> Theme systemTheme = context.getTheme();</span><br><span class="line"><span class="keyword">if</span> (systemTheme.getChangingConfigurations() != <span class="number">0</span>) &#123;</span><br><span class="line">    systemTheme.rebase();</span><br><span class="line">&#125;</span><br><span class="line">mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());</span><br><span class="line">mPackageManagerService.systemReady();</span><br><span class="line">mDisplayManagerService.systemReady(safeMode, mOnlyCore);</span><br><span class="line">mSystemServiceManager.setSafeMode(safeMode);</span><br><span class="line"><span class="comment">// These are needed to propagate to the runnable below.</span></span><br><span class="line"><span class="comment">// 当AMS启动完成之后，在回调中执行下面这些服务的后续操作</span></span><br><span class="line"><span class="keyword">final</span> NetworkManagementService networkManagementF = networkManagement;</span><br><span class="line"><span class="keyword">final</span> NetworkStatsService networkStatsF = networkStats;</span><br><span class="line"><span class="keyword">final</span> NetworkPolicyManagerService networkPolicyF = networkPolicy;</span><br><span class="line"><span class="keyword">final</span> ConnectivityService connectivityF = connectivity;</span><br><span class="line"><span class="keyword">final</span> NetworkScoreService networkScoreF = networkScore;</span><br><span class="line"><span class="keyword">final</span> LocationManagerService locationF = location;</span><br><span class="line"><span class="keyword">final</span> CountryDetectorService countryDetectorF = countryDetector;</span><br><span class="line"><span class="keyword">final</span> NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;</span><br><span class="line"><span class="keyword">final</span> CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;</span><br><span class="line"><span class="keyword">final</span> InputManagerService inputManagerF = inputManager;</span><br><span class="line"><span class="keyword">final</span> TelephonyRegistry telephonyRegistryF = telephonyRegistry;</span><br><span class="line"><span class="keyword">final</span> MediaRouterService mediaRouterF = mediaRouter;</span><br><span class="line"><span class="keyword">final</span> MmsServiceBroker mmsServiceF = mmsService;</span><br><span class="line"><span class="keyword">final</span> WindowManagerService windowManagerF = wm;</span><br><span class="line"><span class="comment">// We now tell the activity manager it is okay to run third party</span></span><br><span class="line"><span class="comment">// code.  It will call back into us once it has gotten to the state</span></span><br><span class="line"><span class="comment">// where third party code can really run (but before it has actually</span></span><br><span class="line"><span class="comment">// started launching the initial applications), for us to complete our</span></span><br><span class="line"><span class="comment">// initialization.</span></span><br><span class="line">mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;, BOOT_TIMINGS_TRACE_LOG);</span><br></pre></td></tr></table></figure><p><code>ActivityManagerService</code>作为启动引导服务，是后续很多服务启动的前提，而且后面应用启动、四大组件启动都和<code>AMS</code>有莫大关系，<code>AMS</code>过于复杂，只待后面分析。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简单来说，<code>SystemServer</code>进程为系统正常运行启动了各种服务，然后进入了死循环，处理进程消息，整体逻辑比较简单，比较复杂的地方是整个过程中涉及<code>binder</code>、<code>ActivityManagerService</code>等的地方，这部分后面再说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SystemServer&lt;/code&gt;是&lt;code&gt;Zygote&lt;/code&gt;进程启动之后fork的第一个子进程，所有的系统服务就在该进程中启动，是android系统良好运转的基础，从此开始，就标志着系统正式启动了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="SystemServer" scheme="https://ymlion.com/tags/SystemServer/"/>
    
  </entry>
  
  <entry>
    <title>Zygote进程分析（后记）</title>
    <link href="https://ymlion.com/post/zygote-sequence-diagram/"/>
    <id>https://ymlion.com/post/zygote-sequence-diagram/</id>
    <published>2017-12-08T03:37:35.000Z</published>
    <updated>2018-04-08T03:49:50.115Z</updated>
    
    <content type="html"><![CDATA[<img src="/post/zygote-sequence-diagram/Zygote进程分析时序图.png" title="Zygote进程分析时序图">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/post/zygote-sequence-diagram/Zygote进程分析时序图.png&quot; title=&quot;Zygote进程分析时序图&quot;&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Zygote" scheme="https://ymlion.com/tags/Zygote/"/>
    
      <category term="SequenceDiagram" scheme="https://ymlion.com/tags/SequenceDiagram/"/>
    
  </entry>
  
  <entry>
    <title>Zygote进程分析</title>
    <link href="https://ymlion.com/post/zygote-analysis/"/>
    <id>https://ymlion.com/post/zygote-analysis/</id>
    <published>2017-12-07T08:59:01.000Z</published>
    <updated>2018-04-08T03:49:50.112Z</updated>
    
    <content type="html"><![CDATA[<p>通过分析<code>Zygote</code>进程的启动过程，也了解到<code>Zygote</code>进程主要作用有三个：</p><ul><li>预加载公共类和资源</li><li>启动<code>SystemServer</code>进程</li><li>通过socket接受消息，并创建应用子进程</li></ul><a id="more"></a><h2 id="预加载公共类和资源"><a href="#预加载公共类和资源" class="headerlink" title="预加载公共类和资源"></a>预加载公共类和资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(BootTimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    preloadClasses();<span class="comment">// 1</span></span><br><span class="line">    ......</span><br><span class="line">    preloadResources();<span class="comment">// 2</span></span><br><span class="line">    ......</span><br><span class="line">    preloadOpenGL();<span class="comment">// 3</span></span><br><span class="line">    ......</span><br><span class="line">    preloadSharedLibraries();<span class="comment">// 4</span></span><br><span class="line">    preloadTextResources();<span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// Ask the WebViewFactory to do any initialization that must run in the zygote process,</span></span><br><span class="line">    <span class="comment">// for memory sharing purposes.</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();<span class="comment">// 6</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>preloadClasses</code>方法通过读取<code>/system/etc/preloaded-classes</code>文件的每一行获取类名，然后通过<code>Class.forName(line, true, null)</code>初始化每一个类。</p><blockquote><p><code>/system/etc/preloaded-classes</code>文件几乎涵盖了所有实际开发中用到的类，另外该文件来自<code>frameworks/base/preloaded-classes</code>，随着版本更替，现在预加载的类已经多达4500多个。</p></blockquote></li><li><p><code>preloadResources</code>方法获取到<code>Resources</code>，然后去加载常用的<code>drawables</code>、<code>color_state_lists</code>，分别对应于<code>com.android.internal.R.array.preloaded_drawables</code>和<code>com.android.internal.R.array.preloaded_color_state_lists</code>。</p></li><li><p>预加载OpenGL。</p></li><li><p>加载共享库，这三个就是平时最常使用的库了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.loadLibrary(<span class="string">"android"</span>);</span><br><span class="line">System.loadLibrary(<span class="string">"compiler_rt"</span>);</span><br><span class="line">System.loadLibrary(<span class="string">"jnigraphics"</span>); <span class="comment">// 提供对java层bitmap对象的可靠操作</span></span><br></pre></td></tr></table></figure></li><li><p>通过<code>TextView.preloadFontCache</code>来建立字体缓存，该方法仅仅是通过计算“H”宽度来实现的。</p></li><li><p><code>WebView</code>中需要预加载的东西，目前只是用于为后面加载JNI库分配地址空间。</p></li></ol><h2 id="启动SystemServer"><a href="#启动SystemServer" class="headerlink" title="启动SystemServer"></a>启动SystemServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare the arguments and fork for the system server process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName, ZygoteServer zygoteServer)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="comment">// 最前面是为创建SystemServer准备参数</span></span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_IPC_LOCK,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_PTRACE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG,</span><br><span class="line">        OsConstants.CAP_WAKE_ALARM</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">/* Containers run without this capability, so avoid setting it in that case */</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemProperties.getBoolean(PROPERTY_RUNNING_IN_CONTAINER, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        capabilities |= posixCapabilitiesAsBits(OsConstants.CAP_BLOCK_SUSPEND);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1032,3001,3002,3003,3006,3007,3009,3010"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 参数解析工具类来解析参数</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">        <span class="comment">/* Request to fork the system server process */</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For child process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">// 子进程创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭socket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先准备创建<code>SystemServer</code>的参数，可以看出进程<code>uid</code>和<code>gid</code>都是100，然后调用<code>Zygote.forkSystemServer</code>来创建，最后通过<code>pid</code>判断是否是子进程即<code>SystemServer</code>进程，若是则进行后续的一些操作，否则直接返回。</p><p>下面看下子进程fork过程，在<code>Zygote.forkSystermServer</code>中没有实际fork代码，但是有fork过程，分为两步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    VM_HOOKS.preFork(); <span class="comment">// 1：关闭垃圾回收相关的守护线程，并初始化堆</span></span><br><span class="line">    <span class="comment">// Resets nice priority for zygote process.</span></span><br><span class="line">    resetNicePriority();</span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(<span class="comment">// 2</span></span><br><span class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    <span class="comment">// Enable tracing as soon as we enter the system_server.</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon(); <span class="comment">// 启动新的垃圾回收相关守护线程</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步是创建前的准备，源码路径为<code>/libcore/dalvik/src/main/java/dalvik/system/ZygoteHooks.java</code>，每次fork前都会调用，紧接着该方法又调用了本地方法<code>/art/runtime/native/dalvik_system_ZygoteHooks.nativePreFork</code>，该函数也没做什么就调用了<code>/art/runtime/runtime.PreZygoteFork</code>函数，同样这个函数就只调用了<code>/art/runtime/gc/heap.PreZygoteFork</code>，到这里就清晰了这一步就是执行堆初始化。</p><p>第二步就是创建进程了，直接调用了本地方法<code>nativeForkSystemServer</code>，该方法在<code>/framework/base/core/jni/com_android_internal_os_Zygote.cpp</code>中，同样该方法也不是创建子进程的地方，又调用了<code>ForkAndSpecializeCommon</code>方法，最终创建出子进程，该方法比较长，大体看一下关键地方：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utility routine to fork zygote and specialize the child process.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint debug_flags, jobjectArray javaRlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">bool</span> is_system_server, jintArray fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jintArray fdsToIgnore,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;<span class="comment">// 非systemserver，则创建进程组</span></span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置gid</span></span><br><span class="line">    SetGids(env, javaGids);</span><br><span class="line">    <span class="comment">// 设置资源范围</span></span><br><span class="line">    SetRLimits(env, javaRlimits);</span><br><span class="line">    <span class="comment">// Linux方法，设置gid和uid</span></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities, permittedCapabilities);</span><br><span class="line">    <span class="comment">// 设置调度策略</span></span><br><span class="line">    SetSchedulerPolicy(env);</span><br><span class="line">    <span class="comment">// 设置安全增强型Linux环境</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make it easier to debug audit logs by setting the main thread's name to the</span></span><br><span class="line">    <span class="comment">// nice name rather than "app_process".</span></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == <span class="literal">NULL</span> &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用Java方法，根据参数值可知为Zygote.callPostForkChildHooks方法</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server, instructionSet);</span><br><span class="line">   </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;<span class="comment">// 父进程即zygote，不做处理</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建进程都在该方法中进行，调用<code>fork</code>之后，则进行一些子进程的属性设置，父进程则忽略。Linux系统创建进程基本是fork+exec方式，这里并没有执行exec相关函数，但也都是copy on write策略。</p><blockquote><p><code>env-&gt;CallStaticVoidMethod</code>是native层调用java层的方法，三个参数，第一个是目标类class对象，第二个是方法对象，后面是参数，其中前两个参数通过下面方式获取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; gZygoteClass = MakeGlobalRefOrDie(env, FindClassOrDie(env, kZygoteClassName));</span><br><span class="line">&gt; gCallPostForkChildHooks = GetStaticMethodIDOrDie(env, gZygoteClass, <span class="string">"callPostForkChildHooks"</span>,                                                <span class="string">"(IZLjava/lang/String;)V"</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>到这里，<code>systemserver</code>进程就创建完成了，后面又回到了<code>ZygoteInit.startSystemServer</code>方法，当pid为0时说明创建的是子进程，然后调用<code>handleSystemServerProcess</code>去处理剩下的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">    <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);<span class="comment">// dex优化</span></span><br><span class="line">        <span class="comment">// Capturing profiles is only supported for debug or eng builds since selinux normally</span></span><br><span class="line">        <span class="comment">// prevents it.</span></span><br><span class="line">        <span class="keyword">boolean</span> profileSystemServer = SystemProperties.getBoolean(</span><br><span class="line">                <span class="string">"dalvik.vm.profilesystemserver"</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (profileSystemServer &amp;&amp; (Build.IS_USERDEBUG || Build.IS_ENG)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File profileDir = Environment.getDataProfilesDePackageDirectory(</span><br><span class="line">                        Process.SYSTEM_UID, <span class="string">"system_server"</span>);</span><br><span class="line">                File profile = <span class="keyword">new</span> File(profileDir, <span class="string">"primary.prof"</span>);</span><br><span class="line">                profile.getParentFile().mkdirs();</span><br><span class="line">                profile.createNewFile();</span><br><span class="line">                String[] codePaths = systemServerClasspath.split(<span class="string">":"</span>);</span><br><span class="line">                VMRuntime.registerAppInfo(profile.getPath(), codePaths);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Failed to set up system server profile"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] args = parsedArgs.remainingArgs;</span><br><span class="line">        <span class="comment">// If we have a non-null system server class path, we'll have to duplicate the</span></span><br><span class="line">        <span class="comment">// existing arguments and append the classpath to it. ART will handle the classpath</span></span><br><span class="line">        <span class="comment">// correctly when we exec a new process.</span></span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] amendedArgs = <span class="keyword">new</span> String[args.length + <span class="number">2</span>];</span><br><span class="line">            amendedArgs[<span class="number">0</span>] = <span class="string">"-cp"</span>;</span><br><span class="line">            amendedArgs[<span class="number">1</span>] = systemServerClasspath;</span><br><span class="line">            System.arraycopy(args, <span class="number">0</span>, amendedArgs, <span class="number">2</span>, args.length);</span><br><span class="line">            args = amendedArgs;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//启动应用</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(), <span class="keyword">null</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Pass the remaining arguments to SystemServer.主要看这个方法，正常systemserver执行的地方</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面代码就略过了，看下<code>ZygoteInit.zygoteInit</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    RuntimeInit.redirectLogStreams(); <span class="comment">// 重定向日志</span></span><br><span class="line">    RuntimeInit.commonInit(); <span class="comment">// 部分内容初始化</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit(); <span class="comment">// zygote init回调</span></span><br><span class="line">    RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); <span class="comment">// 应用初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下<code>RuntimeInit.commonInit()</code>方法初始化了什么内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set handlers; these apply to all threads in the VM. Apps can replace</span></span><br><span class="line"><span class="comment">     * the default handler, but not the pre handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread.setUncaughtExceptionPreHandler(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Install a TimezoneGetter subclass for ZoneInfo.db</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sets handler for java.util.logging to use Android log facilities.</span></span><br><span class="line"><span class="comment">     * The odd "new instance-and-then-throw-away" is a mirror of how</span></span><br><span class="line"><span class="comment">     * the "java.util.logging.config.class" system property works. We</span></span><br><span class="line"><span class="comment">     * can't use the system property here since the logger has almost</span></span><br><span class="line"><span class="comment">     * certainly already been initialized.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sets the default HTTP User-Agent used by HttpURLConnection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wire socket tagging to traffic stats. 流量统计</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If we're running in an emulator launched with "-trace", put the</span></span><br><span class="line"><span class="comment">     * VM into emulator trace profiling mode so that the user can hit</span></span><br><span class="line"><span class="comment">     * F9/F10 at any time to capture traces.  This has performance</span></span><br><span class="line"><span class="comment">     * consequences, so it's not something you want to do always.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String trace = SystemProperties.get(<span class="string">"ro.kernel.android.tracing"</span>);</span><br><span class="line">    <span class="keyword">if</span> (trace.equals(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"NOTE: emulator trace profiling enabled"</span>);</span><br><span class="line">        Debug.enableEmulatorTraceOutput();</span><br><span class="line">    &#125;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释很清楚，就是一些通用设置。<code>ZygoteInit.nativeZygoteInit</code>实现是在<code>AndroidRuntime.cpp</code>中，最后做了什么呢，就是调用了<code>AppRuntime.onZygoteInit</code>，转了一圈回到了<code>app_main.cpp</code>中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// binder操作，较为复杂，涉及binder核心原理，后面binder分析时再研究。</span></span><br><span class="line">    <span class="comment">// /frameworks/native/libs/binder/ProcessState.cpp</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是最后一步初始化工作<code>RuntimeInit.applicationInit</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// We want to be fairly aggressive about heap utilization, to avoid</span></span><br><span class="line">    <span class="comment">// holding on to a lot of memory that isn't needed.</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 参数解析</span></span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        Slog.e(TAG, ex.getMessage());</span><br><span class="line">        <span class="comment">// let the process exit</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The end of of the RuntimeInit event (see #zygoteInit).</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="comment">// Remaining arguments are passed to the start class's static main</span></span><br><span class="line">    <span class="comment">// 通过参数启动对应类的main方法，执行应用自己的代码</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>ZygoteInit.startSystemServer</code>时，可以知道这里的参数值是<code>com.android.server.SystemServer</code>，最后调用的是<code>SystemServer.main</code>方法，这个地方处理比较有意思，下面看下是怎么调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">     * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">     * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">     * up the process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Zygote.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取的方法实例后，没有直接调用，而是抛出了一个异常<code>Zygote.MethodAndArgsCaller</code>，这里的注释也解释很清楚了，在<code>ZygoteInit.main()</code>中， 最后catch到了该异常，并执行了run方法，为啥这么做呢？目的就是清理所有调用过方法的栈帧。</p><p><code>Zygote.MethodAndArgsCaller</code>就一行代码，执行main方法，到这里<code>SystemServer</code>进程开始执行自己的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br></pre></td></tr></table></figure><h2 id="fork子进程"><a href="#fork子进程" class="headerlink" title="fork子进程"></a>fork子进程</h2><p>说到启动过程，<code>SystemServer</code>的启动是系统启动过程，但还有应用程序的启动过程，通过上面的代码可以看出，<code>SystermServer</code>启动后，执行<code>SystemServer.main</code>的时候，<code>ZygoteInit.main</code>方法就结束了。但<code>Zygote</code>进程还有一个工作就是fork其他应用程序，那这是怎么做的呢？就在<code>ZygoteInit.main</code>最后部分，调用了<code>zygoteServer.runSelectLoop(abiList)</code>方法，通过名字就知道是死循环，看下具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runs the zygote process's select loop. Accepts new connections as</span></span><br><span class="line"><span class="comment"> * they happen, and reads commands from connections one spawn-request's</span></span><br><span class="line"><span class="comment"> * worth at a time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Zygote.MethodAndArgsCaller in a child process when a main()</span></span><br><span class="line"><span class="comment"> * should be executed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>); <span class="comment">// 与fds保持一致</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123; <span class="comment">// 有新的连接</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 创建新进程</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有<code>break</code>， 那死循环退出只能靠抛出异常，像上面创建<code>SystemServer</code>一样，通过抛出异常被捕获退出。下面进入<code>ZygoteConnection.runOnce</code>方法创建子进程并抛出异常： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads one start command from the command socket. If successful,</span></span><br><span class="line"><span class="comment"> * a child is forked and a &#123;<span class="doctag">@link</span> Zygote.MethodAndArgsCaller&#125;</span></span><br><span class="line"><span class="comment"> * exception is thrown in that child while in the parent process,</span></span><br><span class="line"><span class="comment"> * the method returns normally. On failure, the child is not</span></span><br><span class="line"><span class="comment"> * spawned and messages are printed to the log and stderr. Returns</span></span><br><span class="line"><span class="comment"> * a boolean status value indicating whether an end-of-file on the command</span></span><br><span class="line"><span class="comment"> * socket has been encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> false if command socket should continue to be read from, or</span></span><br><span class="line"><span class="comment"> * true if an end-of-file has been encountered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Zygote.MethodAndArgsCaller trampoline to invoke main()</span></span><br><span class="line"><span class="comment"> * method in child process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">(ZygoteServer zygoteServer)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ......<span class="comment">// 很长，省略很多</span></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 从socket中读取出参数信息，然后解析</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">        ......</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">"Zygote security policy prevents request: "</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            <span class="comment">// should never get here, the child is expected to either</span></span><br><span class="line">            <span class="comment">// throw Zygote.MethodAndArgsCaller or exec(). 已抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// in parent...pid of &lt; 0 means failure</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比较长，参数准备好之后就直接调用<code>Zygote.forkAndSpecialize</code>来创建进程了，该方法和<code>forkSystemServer</code>差不多， 只是创建进程调用的是<code>nativeForkAndSpecialize</code>，但该本地方法最终还是调用<code>ForkAndSpecializeCommon</code>，这就回到了同<code>SystemServer</code>进程创建相同的地方，就不再分析。下面看下创建成功后的后续工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles post-fork setup of child proc, closing sockets as appropriate,</span></span><br><span class="line"><span class="comment"> * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller</span></span><br><span class="line"><span class="comment"> * if successful or returning if failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parsedArgs non-null; zygote args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> descriptors null-ok; new file descriptors for stdio if available.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pipeFd null-ok; pipe for communication back to Zygote.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStderr null-ok; stream to use for stderr until stdio</span></span><br><span class="line"><span class="comment"> * is reopened.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Zygote.MethodAndArgsCaller on success to</span></span><br><span class="line"><span class="comment"> * trampoline to code that invokes static main.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * By the time we get here, the native code has closed the two actual Zygote</span></span><br><span class="line"><span class="comment">     * socket connections, and substituted /dev/null in their place.  The LocalSocket</span></span><br><span class="line"><span class="comment">     * objects still need to be closed properly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    closeSocket(); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123; <span class="comment">// 重新打开stdio</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line">            <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error reopening stdio"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123; <span class="comment">// 设置进程名称</span></span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123; <span class="comment">// 特殊情况下执行</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 正常情况下执行</span></span><br><span class="line">        ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的最后一步和<code>SystemServer</code>最后执行的是相同的，正常情况下是执行<code>ZygoteInit.zygoteInit</code>方法，启动对应的main方法，应用程序启动都是调用<code>ActivityThread.main</code>方法。但这次分析上面没有分析的<code>WrapperInit.execApplication</code>方法，找到进程最终的main入口。</p><blockquote><p>每一个应用程序启动是<code>ActivityManagerService</code>控制的，最后通过<code>ZygoteProcess</code>类中的静态方法完成参数设置，并通过socket传递命令给Zygote进程，然后就是上面的<code>runSelectLoop</code>方法读取命令来执行这一系列进程创建过程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes a runtime application with a wrapper command.</span></span><br><span class="line"><span class="comment"> * This method never returns.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invokeWith The wrapper command.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> niceName The nice name for the application, or null if none.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSdkVersion The target SDK version for the app.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pipeFd The pipe to which the application's pid should be written, or null if none.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args Arguments for &#123;<span class="doctag">@link</span> RuntimeInit#main&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execApplication</span><span class="params">(String invokeWith, String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> targetSdkVersion, String instructionSet, FileDescriptor pipeFd,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] args)</span> </span>&#123;</span><br><span class="line">    StringBuilder command = <span class="keyword">new</span> StringBuilder(invokeWith);</span><br><span class="line">    <span class="keyword">final</span> String appProcess;</span><br><span class="line">    <span class="keyword">if</span> (VMRuntime.is64BitInstructionSet(instructionSet)) &#123;</span><br><span class="line">        appProcess = <span class="string">"/system/bin/app_process64"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        appProcess = <span class="string">"/system/bin/app_process32"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    command.append(<span class="string">' '</span>);</span><br><span class="line">    command.append(appProcess);</span><br><span class="line">    command.append(<span class="string">" /system/bin --application"</span>);</span><br><span class="line">    <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        command.append(<span class="string">" '--nice-name="</span>).append(niceName).append(<span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这行代码是重点，WrapperInit被作为参数传入</span></span><br><span class="line">    command.append(<span class="string">" com.android.internal.os.WrapperInit "</span>);</span><br><span class="line">    command.append(pipeFd != <span class="keyword">null</span> ? pipeFd.getInt$() : <span class="number">0</span>);</span><br><span class="line">    command.append(<span class="string">' '</span>);</span><br><span class="line">    command.append(targetSdkVersion);</span><br><span class="line">    Zygote.appendQuotedShellArgs(command, args);</span><br><span class="line">    preserveCapabilities();</span><br><span class="line">    Zygote.execShell(command.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法拼接命令参数，然后调用<code>Zygote.execShell</code>，该方法最终调用系统<code>exec</code>族中的某个方法去执行<code>/system/bin/sh -c &lt;command&gt;</code>命令，一层层调用推进，最终在<code>libcore/luni/src/main/native/libcore_io_Linux.Linux_execv</code>方法中调用了系统方法<code>execv</code>来执行。<code>exec</code>系列系统方法的作用就是在fork出新进程之后，将新进程从父进程剥离开来，为新进程开辟新的空间，执行新进程自己的代码。这就和Linux系统传统的创建进程方法是相同的。</p><p>通过代码，大体能知道拼接的命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;invoke值&gt; /system/bin/app_process /system/bin --application --nice-name=&lt;名称&gt; com.android.internal.os.WrapperInit &lt;pipeFd&gt; &lt;targetSdk&gt; &lt;其他参数&gt;</span><br></pre></td></tr></table></figure><p>看到这个命令，感觉有点眼熟？就和<code>Zygote</code>启动的命令相似，命令程序、目录及后面的参数都差不多。既然执行命令的程序是一个，那就又回到了<code>/frameworks/base/cmds/app_process/app_main.cpp</code>中，这里再回顾下其main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里，设置了className为com.android.internal.os.WrapperInit</span></span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 退出循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We're not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        <span class="comment">// 保存类及参数</span></span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!LOG_NDEBUG) &#123;</span><br><span class="line">          String8 restOfArgs;</span><br><span class="line">          <span class="keyword">char</span>* <span class="keyword">const</span>* argv_new = argv + i;</span><br><span class="line">          <span class="keyword">int</span> argc_new = argc - i;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; argc_new; ++k) &#123;</span><br><span class="line">            restOfArgs.append(<span class="string">"\""</span>);</span><br><span class="line">            restOfArgs.append(argv_new[k]);</span><br><span class="line">            restOfArgs.append(<span class="string">"\" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ALOGV(<span class="string">"Class name = %s, args = %s"</span>, className.<span class="built_in">string</span>(), restOfArgs.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">      <span class="comment">// AndroidRuntime.start启动DVM、注册本地方法，然后启动RuntimeInit.main</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析完参数，最后<code>runtime.start</code>同启动<code>zygote</code>一样，也是三步，最终调用<code>RuntimeInit.main</code>方法。这个main方法比较简单，和<code>ZygoteInit.zygoteInit</code>部分相似，也是一些初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> </span>&#123;</span><br><span class="line">    enableDdms();</span><br><span class="line">    <span class="keyword">if</span> (argv.length == <span class="number">2</span> &amp;&amp; argv[<span class="number">1</span>].equals(<span class="string">"application"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application"</span>);</span><br><span class="line">        redirectLogStreams();<span class="comment">// 同样执行该方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting tool"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    commonInit(); <span class="comment">// 同样执行该方法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now that we're running in interpreted code, call back into native code</span></span><br><span class="line"><span class="comment">     * to run the system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 这个本地方法时关键</span></span><br><span class="line">    nativeFinishInit();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Leaving RuntimeInit!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看，代码里面没有要启动<code>WrapperInit.main</code>代码，关键的地方就是最后的<code>nativeFinishInit</code>方法，该方法实现同样是在<code>AndroidRuntime.cpp</code>中，就一行代码去回调runtime实例的<code>onStarted</code>方法，在<code>AppRuntime</code>类中，再回到<code>/frameworks/base/cmds/app_process/app_main.cpp</code>文件中，在其main方法中，runtime对象是将类和参数保存了下来，来看下<code>AppRuntime</code>的两个回调方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mClassName.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">return</span>; <span class="comment">// Zygote. Nothing to do here.</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This is a little awkward because the JNI FindClass call uses the</span></span><br><span class="line"><span class="comment">        * class loader associated with the native method we're executing in.</span></span><br><span class="line"><span class="comment">        * If called in onStarted (from RuntimeInit.finishInit because we're</span></span><br><span class="line"><span class="comment">        * launching "am", for example), FindClass would see that we're calling</span></span><br><span class="line"><span class="comment">        * from a boot class' native method, and so wouldn't look for the class</span></span><br><span class="line"><span class="comment">        * we're trying to look up in CLASSPATH. Unfortunately it needs to,</span></span><br><span class="line"><span class="comment">        * because the "am" classes are not boot classes.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The easiest fix is to call FindClass here, early on before we start</span></span><br><span class="line"><span class="comment">        * executing boot class Java code and thereby deny ourselves access to</span></span><br><span class="line"><span class="comment">        * non-boot classes.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">char</span>* slashClassName = toSlashClassName(mClassName.<span class="built_in">string</span>());</span><br><span class="line">       mClass = env-&gt;FindClass(slashClassName); <span class="comment">// 找到该类</span></span><br><span class="line">       <span class="keyword">if</span> (mClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           ALOGE(<span class="string">"ERROR: could not find class '%s'\n"</span>, mClassName.<span class="built_in">string</span>());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">       mClass = <span class="keyword">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;NewGlobalRef(mClass));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onStarted</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">       ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">       proc-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">       AndroidRuntime* ar = AndroidRuntime::getRuntime();</span><br><span class="line">       ar-&gt;callMain(mClassName, mClass, mArgs);</span><br><span class="line"></span><br><span class="line">       IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">       hardware::IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>onVmCreated</code>回调中根据类名反射获取到类对象，在<code>onStarted</code>中调用了该类的main方法。从这里就进入了<code>WrapperInit.main</code>方法，代码逻辑设计很巧妙，一环套一环，又回到了原点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过wrapper process启动应用才会执行到这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Mimic system Zygote preloading. 预加载公共类和资源</span></span><br><span class="line">        ZygoteInit.preload(<span class="keyword">new</span> BootTimingsTraceLog(<span class="string">"WrapperInitTiming"</span>,</span><br><span class="line">                Trace.TRACE_TAG_DALVIK));</span><br><span class="line">        <span class="comment">// Launch the application. </span></span><br><span class="line">        String[] runtimeArgs = <span class="keyword">new</span> String[args.length - <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(args, <span class="number">2</span>, runtimeArgs, <span class="number">0</span>, runtimeArgs.length);</span><br><span class="line">        WrapperInit.wrapperInit(targetSdkVersion, runtimeArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Zygote.MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();<span class="comment">// 捕获异常，并执行ActivityThread.main方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ClassLoader，然后和正常创建其他子进程一样，执行applicationInit方法，最后抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wrapperInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">// Check whether the first argument is a "-cp" in argv, and assume the next argument is the</span></span><br><span class="line">    <span class="comment">// classpath. If found, create a PathClassLoader and use it for applicationInit.</span></span><br><span class="line">    ClassLoader classLoader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (argv != <span class="keyword">null</span> &amp;&amp; argv.length &gt; <span class="number">2</span> &amp;&amp; argv[<span class="number">0</span>].equals(<span class="string">"-cp"</span>)) &#123;</span><br><span class="line">        classLoader = ZygoteInit.createPathClassLoader(argv[<span class="number">1</span>], targetSdkVersion);</span><br><span class="line">        <span class="comment">// Install this classloader as the context classloader, too.</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">        <span class="comment">// Remove the classpath from the arguments.</span></span><br><span class="line">        String removedArgs[] = <span class="keyword">new</span> String[argv.length - <span class="number">2</span>];</span><br><span class="line">        System.arraycopy(argv, <span class="number">2</span>, removedArgs, <span class="number">0</span>, argv.length - <span class="number">2</span>);</span><br><span class="line">        argv = removedArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面就和前面分析<code>SystemServer</code>创建是一样的了，简单的区别就是<code>SystemServer</code>进程执行<code>SystemServer.main</code>，普通应用从<code>ActivityThread.main</code>开始。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个Zygote进程的作用基本分析完了，个别细节或许不太详细，但重要的点基本都有。主要工作就三个：</p><ul><li>预加载公共类和资源</li><li>创建<code>SystemServer</code></li><li>创建其他应用程序</li></ul><p>下面再总结下子进程创建的一些区别或注意点：</p><ol><li><code>SystemServer</code>在系统启动或者说<code>zygote</code>进程创建时就紧接着创建了，而应用进程需要在某些情况下被创建，因此<code>zygote</code>进程进入死循环，通过socket来获取命令来创建应用进程。</li><li>上面的代码可以看到，进程创建有两种方式，一种是正常的，另一种是wrapper方式，wrapper方式通过invoke-with参数控制。wrapper方式是按照Linux正常的创建流程即fork+exec，而正常方式则没有exec。</li><li>正常方式最后执行<code>ZygoteInit.zygoteInit</code>方法进行初始化及进程入口调用；而wrapper方式则通过exec复制出新进程空间，而后回到了<code>app_main.cpp</code>中，“重走”<code>zygote</code>创建流程，较为复杂。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过分析&lt;code&gt;Zygote&lt;/code&gt;进程的启动过程，也了解到&lt;code&gt;Zygote&lt;/code&gt;进程主要作用有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预加载公共类和资源&lt;/li&gt;
&lt;li&gt;启动&lt;code&gt;SystemServer&lt;/code&gt;进程&lt;/li&gt;
&lt;li&gt;通过socket接受消息，并创建应用子进程&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Zygote" scheme="https://ymlion.com/tags/Zygote/"/>
    
  </entry>
  
  <entry>
    <title>Android启动过程分析</title>
    <link href="https://ymlion.com/post/android-startup/"/>
    <id>https://ymlion.com/post/android-startup/</id>
    <published>2017-11-29T13:32:48.000Z</published>
    <updated>2018-04-08T03:49:49.981Z</updated>
    
    <content type="html"><![CDATA[<p>android系统的第一个进程是<code>init</code>，<code>init</code>进程通过解析<code>init.rc</code>文件来启动android系统服务进程，最重要是<code>Zygote</code>进程和<code>ServiceManage</code>。启动相关的代码也一直随着版本变化，下面基于<a href="https://www.androidos.net.cn/android/8.0.0_r4/xref" target="_blank" rel="noopener">8.0.0_r4</a>版本来看下这两个进程的启动过程。</p><a id="more"></a><blockquote><p>rc文件相关语法在<code>/system/core/init/README.md</code>中有详细介绍。</p></blockquote><h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><p>在<code>system/core/rootdir/init.rc</code>中可以找到相关<code>servicemanager</code>的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop and</span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    # start essential services</span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanager</span><br><span class="line">    ........</span><br></pre></td></tr></table></figure><p>在<code>post-fs</code>action触发后，就直接启动了几个必要的服务，其中就包括<code>servicemanager</code>，这个时候还要看一下<code>post-fs</code>是在什么时候触发的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Mount filesystems and start core system services.</span><br><span class="line">on late-init</span><br><span class="line">    trigger early-fs</span><br><span class="line"></span><br><span class="line">    # Mount fstab in init.&#123;$device&#125;.rc by mount_all command. Optional parameter</span><br><span class="line">    # &apos;--early&apos; can be specified to skip entries with &apos;latemount&apos;.</span><br><span class="line">    # /system and /vendor must be mounted by the end of the fs stage,</span><br><span class="line">    # while /data is optional.</span><br><span class="line">    trigger fs</span><br><span class="line">    # 就在这了</span><br><span class="line">    trigger post-fs</span><br><span class="line"></span><br><span class="line">    # Mount fstab in init.&#123;$device&#125;.rc by mount_all with &apos;--late&apos; parameter</span><br><span class="line">    # to only mount entries with &apos;latemount&apos;. This is needed if &apos;--early&apos; is</span><br><span class="line">    # specified in the previous mount_all command on the fs stage.</span><br><span class="line">    # With /system mounted and properties form /system + /factory available,</span><br><span class="line">    # some services can be started.</span><br><span class="line">    trigger late-fs</span><br><span class="line"></span><br><span class="line">    # Now we can mount /data. File encryption requires keymaster to decrypt</span><br><span class="line">    # /data, which in turn can only be loaded when system properties are present.</span><br><span class="line">    trigger post-fs-data</span><br><span class="line"></span><br><span class="line">    # Now we can start zygote for devices with file based encryption</span><br><span class="line">    # 这个也值得注意</span><br><span class="line">    trigger zygote-start</span><br><span class="line"></span><br><span class="line">    # Load persist properties and override properties (if enabled) from /data.</span><br><span class="line">    trigger load_persist_props_action</span><br><span class="line"></span><br><span class="line">    # Remove a file to wake up anything waiting for firmware.</span><br><span class="line">    trigger firmware_mounts_complete</span><br><span class="line"></span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br></pre></td></tr></table></figure><p>在<code>late-init</code>触发后，就会执行<code>post-fs</code>，当然稍微向后看几步，就能看的<code>zygote-start</code>也被触发了，这个也就是启动<code>zygote</code>进程的。</p><p>同样<code>late-init</code>的触发也是需要前提的，继续看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Healthd can trigger a full boot from charger mode by signaling this</span><br><span class="line"># property when the power button is held.</span><br><span class="line">on property:sys.boot_from_charger_mode=1</span><br><span class="line">    class_stop charger</span><br><span class="line">    trigger late-init</span><br></pre></td></tr></table></figure><p>这是其中一处，真正正常启动不是这个地方，<code>init.rc</code>中找不到，再去<code>system/core/init/init.cpp</code>中看一下<code>main</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line"><span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">"set_mmap_rnd_bits"</span>);</span><br><span class="line">am.QueueBuiltinAction(set_kptr_restrict_action, <span class="string">"set_kptr_restrict"</span>);</span><br><span class="line">am.QueueBuiltinAction(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">am.QueueBuiltinAction(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line"><span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">"ro.bootmode"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 后面就是一个while(true)循环</span></span><br></pre></td></tr></table></figure><p>在<code>main</code>函数最后部分，可以看到依次触发了<code>erlay-init</code>、<code>init</code>、<code>late-init</code>action，在这里终于找到了<code>servicemanager</code>和<code>zygote</code>进程启动的前提。</p><p>最后看下<code>servicemanager</code>服务（<code>frameworks/native/cmds/servicemanager/servicemanager.rc</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 名称及该程序的设备存储路径</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    # class名称</span><br><span class="line">    class core animation</span><br><span class="line">    # 用户</span><br><span class="line">    user system</span><br><span class="line">    # 用户组</span><br><span class="line">    group system readproc</span><br><span class="line">    # 表明至关重要</span><br><span class="line">    critical</span><br><span class="line">    # 重启该服务，则需要重启以下服务</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br></pre></td></tr></table></figure><h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p>在上面提到过，触发<code>late-init</code>之后就执行了<code>zygote-start</code>action：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># It is recommended to put unnecessary data/ initialization from post-fs-data</span><br><span class="line"># to start-zygote in device&apos;s init.rc to unblock zygote start.</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=unencrypted</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br></pre></td></tr></table></figure><p>看到还有一个条件<code>ro.crypto.state</code>，这个有三个值，上面的代码是其中一个，这个属性是全盘加密，正常启动时没有加密的，但是三个不同值执行的代码其实是一样的。<code>init.{ro.zygote}.rc</code>根据实际情况有四种：</p><ul><li>init.zygote32.rc：zygote 进程对应的执行程序是 app_process (纯 32bit 模式)</li><li>init.zygote64.rc：zygote 进程对应的执行程序是 app_process64 (纯 64bit 模式)</li><li>init.zygote32_64.rc：启动两个 zygote 进程 (名为 zygote 和 zygote_secondary)，对应的执行程序分别是 app_process32 (主模式)、app_process64。</li><li>init.zygote64_32.rc：启动两个 zygote 进程 (名为 zygote 和 zygote_secondary)，对应的执行程序分别是 app_process64 (主模式)、app_process32。</li></ul><p>下面看下<code>init.zygote64_32.rc</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary --enable-lazy-preload</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc</span><br><span class="line">    socket zygote_secondary stream 660 root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><p>通过与<code>servicemanager</code>对比，可以发现<code>zygote</code>所属用户（组）、class等都是不同的，并且存储路径后面跟有几个参数，以此来启动<code>zygote</code>。</p><h3 id="app-main"><a href="#app-main" class="headerlink" title="app_main"></a>app_main</h3><p>下面找到启动<code>zygote</code>的代码，在<code>/frameworks/base/cmds/app_process/app_main.cpp</code>，看下其<code>main</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建AppRuntime对象</span></span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是参数解释</span></span><br><span class="line">    <span class="comment">// 第一个参数传给虚拟机</span></span><br><span class="line">    <span class="comment">// Everything up to '--' or first non '-' arg goes to the vm.</span></span><br><span class="line">    <span class="comment">// 后面的/system/bin是执行文件所在目录</span></span><br><span class="line">    <span class="comment">// The first argument after the VM args is the "parent dir", which</span></span><br><span class="line">    <span class="comment">// is currently unused.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// After the parent dir, we expect one or more the following internal</span></span><br><span class="line">    <span class="comment">// arguments :</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// --zygote : Start in zygote mode 指定ZygoteInit启动</span></span><br><span class="line">    <span class="comment">// --start-system-server : Start the system server. </span></span><br><span class="line">    <span class="comment">// Zygote要启动SystemServer</span></span><br><span class="line">    <span class="comment">// --application : Start in application (stand alone, non zygote) mode.</span></span><br><span class="line">    <span class="comment">// --nice-name : The nice name for this process.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// For non zygote starts, these arguments will be followed by</span></span><br><span class="line">    <span class="comment">// the main class name. All remaining arguments are passed to</span></span><br><span class="line">    <span class="comment">// the main method of this class.</span></span><br><span class="line">    <span class="comment">// 剩余的参数都会传给Zygote</span></span><br><span class="line">    <span class="comment">// For zygote starts, all remaining arguments are passed to the zygote.</span></span><br><span class="line">    <span class="comment">// main function.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that we must copy argument string values since we will rewrite the</span></span><br><span class="line">    <span class="comment">// entire argument block when we apply the nice name to argv0.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// As an exception to the above rule, anything in "spaced commands"</span></span><br><span class="line">    <span class="comment">// goes to the vm even though it has a space in it.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* spaced_commands[] = &#123; <span class="string">"-cp"</span>, <span class="string">"-classpath"</span> &#125;;</span><br><span class="line">    <span class="comment">// Allow "spaced commands" to be succeeded by exactly 1 argument (regardless of -s).</span></span><br><span class="line">    <span class="keyword">bool</span> known_command = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (known_command == <span class="literal">true</span>) &#123;</span><br><span class="line">          runtime.addOption(strdup(argv[i]));</span><br><span class="line">          ALOGV(<span class="string">"app_process main add known option '%s'"</span>, argv[i]);</span><br><span class="line">          known_command = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">             j &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">sizeof</span>(spaced_commands) / <span class="keyword">sizeof</span>(spaced_commands[<span class="number">0</span>]));</span><br><span class="line">             ++j) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[i], spaced_commands[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">            known_command = <span class="literal">true</span>;</span><br><span class="line">            ALOGV(<span class="string">"app_process main found known command '%s'"</span>, argv[i]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">        ALOGV(<span class="string">"app_process main add option '%s'"</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We're not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!LOG_NDEBUG) &#123;</span><br><span class="line">          String8 restOfArgs;</span><br><span class="line">          <span class="keyword">char</span>* <span class="keyword">const</span>* argv_new = argv + i;</span><br><span class="line">          <span class="keyword">int</span> argc_new = argc - i;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; argc_new; ++k) &#123;</span><br><span class="line">            restOfArgs.append(<span class="string">"\""</span>);</span><br><span class="line">            restOfArgs.append(argv_new[k]);</span><br><span class="line">            restOfArgs.append(<span class="string">"\" "</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          ALOGV(<span class="string">"Class name = %s, args = %s"</span>, className.<span class="built_in">string</span>(), restOfArgs.<span class="built_in">string</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 准备启动Zygote</span></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>函数中，主要是解析传递进来的参数，并初始化<code>AppRuntime</code>对象，该类继承自<code>AndroidRuntime</code>，最后执行<code>AndroidRuntime.start</code>函数。</p><h3 id="AndroidRuntime"><a href="#AndroidRuntime" class="headerlink" title="AndroidRuntime"></a>AndroidRuntime</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></span><br><span class="line"><span class="comment"> * and calling the "static void main(String[] args)" method in the class</span></span><br><span class="line"><span class="comment"> * named by "className".</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></span><br><span class="line"><span class="comment"> * options string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment">     * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment">     * Create an array to hold them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(slashClassName);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AndroidRuntime</code>类路径是<code>/frameworks/base/core/jni/AndroidRuntime.cpp</code>，通过<code>start</code>函数的注释就知道该函数的主要作用：</p><ul><li>通过<code>startVm(&amp;mJavaVM, &amp;env, zygote)</code>启动了Dalvik VM；</li><li>通过<code>(startReg(env)</code>注册android本地方法；</li><li>根据参数<code>className</code>获取到<code>ZygoteInit</code>类，然后获取<code>main</code>方法，最后通过<code>env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</code>启动<code>ZygoteInit.main</code>方法，并把参数传递过去。</li></ul><h3 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h3><p>该类就是来启动<code>zygote</code>进程，启动后<code>zygote</code>进程除了预加载一些类，最主要的就是fork<code>SystemServer</code>进程和其他子进程，其中<code>SystemServer</code>进程主要孕育了大部分系统主要服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">    <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="comment">// 不允许在Zygote中创建线程</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Report Zygote start time to tron unless it is a runtime restart</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>))) &#123;</span><br><span class="line">            MetricsLogger.histogram(<span class="keyword">null</span>, <span class="string">"boot_zygote_init"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>) SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line">        String bootTimeTag = Process.is64Bit() ? <span class="string">"Zygote64Timing"</span> : <span class="string">"Zygote32Timing"</span>;</span><br><span class="line">        BootTimingsTraceLog bootTimingsTraceLog = <span class="keyword">new</span> BootTimingsTraceLog(bootTimeTag,</span><br><span class="line">                Trace.TRACE_TAG_DALVIK);</span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">"ZygoteInit"</span>);</span><br><span class="line">        <span class="comment">// 启动DDMS</span></span><br><span class="line">        RuntimeInit.enableDdms();</span><br><span class="line">        <span class="comment">// Start profiling the zygote initialization.</span></span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 解析参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (abiList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No ABI list supplied."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册socket，名称为zygote，用于进程间通信</span></span><br><span class="line">        zygoteServer.registerServerSocket(socketName);</span><br><span class="line">        <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">        <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            bootTimingsTraceLog.traceBegin(<span class="string">"ZygotePreload"</span>);</span><br><span class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">            <span class="comment">// 预加载公共类资源，用于fork子程序</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">            bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygotePreload</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Zygote.resetNicePriority();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Finish profiling the zygote initialization.</span></span><br><span class="line">        SamplingProfilerIntegration.writeZygoteSnapshot();</span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">"PostZygoteInitGC"</span>);</span><br><span class="line">        gcAndFinalize();<span class="comment">// gc操作</span></span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// PostZygoteInitGC</span></span><br><span class="line">        bootTimingsTraceLog.traceEnd(); <span class="comment">// ZygoteInit</span></span><br><span class="line">        <span class="comment">// Disable tracing so that forked processes do not inherit stale tracing tags fr</span></span><br><span class="line">        <span class="comment">// Zygote.</span></span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// Zygote process unmounts root storage spaces.</span></span><br><span class="line">        Zygote.nativeUnmountStorageOnInit();</span><br><span class="line">        <span class="comment">// Set seccomp policy</span></span><br><span class="line">        Seccomp.setPolicy();</span><br><span class="line">        <span class="comment">// 关闭不允许创建线程</span></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            <span class="comment">// 启动system server</span></span><br><span class="line">            startSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        <span class="comment">// 关闭退出</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Zygote.MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，<code>Zygote</code>和<code>ServiceManager</code>的启动过程就结束了，简单梳理下流程。</p><ol><li><p><code>ServiceManager</code>启动：</p><p><code>init</code>进程执行一系列初始化的<code>action</code>，其中<code>late-init</code>之后执行<code>post-fs</code>，然后启动<code>ServiceManager</code>。</p></li><li><p>Zygote启动：</p><p>同样在<code>late-init</code>之后就执行了<code>zygote-start</code>，然后进入启动<code>Zygote</code>的一系列代码。</p><ul><li><code>app_main</code>的<code>main</code>函数中解析参数，传递给<code>AndroidRuntime</code>；</li><li><code>AndroidRuntime.start</code>函数开始启动虚拟机，并调用<code>ZygoteInit.main</code>方法；</li><li>在<code>ZygoteInit.main</code>中，<code>Zygote</code>进程启动，预加载公共类和资源，并首先fork第一个子进程<code>SystemServer</code>。</li></ul></li></ol><p>限于篇幅原因，<code>Zygote</code>进程具体做了什么，就留在后面继续分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;android系统的第一个进程是&lt;code&gt;init&lt;/code&gt;，&lt;code&gt;init&lt;/code&gt;进程通过解析&lt;code&gt;init.rc&lt;/code&gt;文件来启动android系统服务进程，最重要是&lt;code&gt;Zygote&lt;/code&gt;进程和&lt;code&gt;ServiceManage&lt;/code&gt;。启动相关的代码也一直随着版本变化，下面基于&lt;a href=&quot;https://www.androidos.net.cn/android/8.0.0_r4/xref&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;8.0.0_r4&lt;/a&gt;版本来看下这两个进程的启动过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Zygote" scheme="https://ymlion.com/tags/Zygote/"/>
    
  </entry>
  
  <entry>
    <title>View绘制流程</title>
    <link href="https://ymlion.com/post/view-draw/"/>
    <id>https://ymlion.com/post/view-draw/</id>
    <published>2017-11-17T09:29:19.000Z</published>
    <updated>2018-04-08T03:49:50.054Z</updated>
    
    <content type="html"><![CDATA[<img src="/post/view-draw/View绘制.png" title="View绘制流程图"><p>View绘制流程基本上是在<code>ViewRootImpl.java</code>中进行的，上面的流程图是按照第一次加载时的顺序。measure和layout过程没有太多复杂的地方，下面说下draw部分，尤其是在<code>ViewGroup</code>的draw流程。</p><a id="more"></a><h2 id="draw逻辑"><a href="#draw逻辑" class="headerlink" title="draw逻辑"></a>draw逻辑</h2><p>根据<code>View.draw</code>方法中的注释和代码，整个绘制步骤有6步，当然不是每一步都会执行，甚至都不执行。</p><ol><li>Draw the background</li><li>If necessary, save the canvas’ layers to prepare for fading</li><li>Draw view’s content</li><li>Draw children</li><li>If necessary, draw the fading edges and restore layers</li><li>Draw decorations (scrollbars for instance)</li></ol><p>view的绘制中，基本逻辑就是在<code>draw(Canvas canvas)</code>中进行的，正常情况下是会忽略第2和5步的，除非设置了垂直或水平的颜色渐变。</p><p><img src="draw流程.png" alt="draw流程"></p><h2 id="ViewGroup-draw执行条件"><a href="#ViewGroup-draw执行条件" class="headerlink" title="ViewGroup draw执行条件"></a>ViewGroup draw执行条件</h2><p>ViewGroup基本是不需要draw自己的，只是去draw children，目前大部分情况下，只有两种情况下会draw自己：</p><ul><li>setWillNotDraw(false)：会设置<code>PFLAG_SKIP_DRAW</code>标志</li><li>设置背景</li></ul><p>在<code>setFlags</code>方法中有是否会设置<code>PFLAG_SKIP_DRAW</code>的几行代码，正是验证了上面两种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mViewFlags &amp; WILL_NOT_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mBackground != <span class="keyword">null</span></span><br><span class="line">            || mDefaultFocusHighlight != <span class="keyword">null</span></span><br><span class="line">            || (mForegroundInfo != <span class="keyword">null</span> &amp;&amp; mForegroundInfo.mDrawable != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_SKIP_DRAW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_SKIP_DRAW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatchDraw</code>方法就是开始循环绘制子View了，该方法的实现是在ViewGroup中，自定义View时也可以定制该方法，绘制子View的逻辑会在<code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>，这也是该方法唯一被调用的地方。该方法通过判断是否有<code>PFLAG_SKIP_DRAW</code>标志决定是否执行子View的draw(canvas)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line"><span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个draw过程需要注意的就是ViewGroup的draw过程，View是总会执行的。</p><h2 id="ViewGroup-onDraw执行条件"><a href="#ViewGroup-onDraw执行条件" class="headerlink" title="ViewGroup onDraw执行条件"></a>ViewGroup onDraw执行条件</h2><p>ViewGroup执行draw方法之后，draw一开始先是判断<code>dirtyOpaque</code>的值，即判断是否有标志<code>PFLAG_DIRTY_OPAQUE</code>，若有则为<code>true</code>，否则为false。该值决定了是否执行<code>drawBackground</code>和<code>onDraw</code>方法，众所周知，View是会执行这两个方法的，但为什么ViewGroup会有时不执行呢？两者的区别是有没有子View，这样看来，是否有标志<code>PFLAG_DIRTY_OPAQUE</code>和子View应该有关系，接下来就先去找该标志被设置的地方，最终锁定到<code>ViewGroup.invalidateChild(View child, final Rect dirty)</code>方法，该方法是在<strong>子View</strong>执行<code>invalidate</code>时执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span> &amp;&amp; attachInfo.mHardwareAccelerated) &#123;</span><br><span class="line">        <span class="comment">// HW accelerated fast path</span></span><br><span class="line">        onDescendantInvalidated(child, child);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the child is drawing an animation, we want to copy this flag onto</span></span><br><span class="line">        <span class="comment">// ourselves and the parent to make sure the invalidate request goes</span></span><br><span class="line">        <span class="comment">// through</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> drawAnimation = (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether the child that requests the invalidate is fully opaque</span></span><br><span class="line">        <span class="comment">// Views being animated or transformed are not considered opaque because we may</span></span><br><span class="line">        <span class="comment">// be invalidating their old position and need the parent to paint behind them.</span></span><br><span class="line">        Matrix childMatrix = child.getMatrix();</span><br><span class="line">        <span class="comment">// 通过子View的isOpaque方法判断</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isOpaque = child.isOpaque() &amp;&amp; !drawAnimation &amp;&amp;</span><br><span class="line">                child.getAnimation() == <span class="keyword">null</span> &amp;&amp; childMatrix.isIdentity();</span><br><span class="line">        <span class="comment">// Mark the child as dirty, using the appropriate flag</span></span><br><span class="line">        <span class="comment">// Make sure we do not set both flags at the same time</span></span><br><span class="line">        <span class="keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] location = attachInfo.mInvalidateChildLocation;</span><br><span class="line">        location[CHILD_LEFT_INDEX] = child.mLeft;</span><br><span class="line">        location[CHILD_TOP_INDEX] = child.mTop;</span><br><span class="line">        <span class="keyword">if</span> (!childMatrix.isIdentity() ||</span><br><span class="line">                (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">            RectF boundingRect = attachInfo.mTmpTransformRect;</span><br><span class="line">            boundingRect.set(dirty);</span><br><span class="line">            Matrix transformMatrix;</span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">                Transformation t = attachInfo.mTmpTransformation;</span><br><span class="line">                <span class="keyword">boolean</span> transformed = getChildStaticTransformation(child, t);</span><br><span class="line">                <span class="keyword">if</span> (transformed) &#123;</span><br><span class="line">                    transformMatrix = attachInfo.mTmpMatrix;</span><br><span class="line">                    transformMatrix.set(t.getMatrix());</span><br><span class="line">                    <span class="keyword">if</span> (!childMatrix.isIdentity()) &#123;</span><br><span class="line">                        transformMatrix.preConcat(childMatrix);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    transformMatrix = childMatrix;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                transformMatrix = childMatrix;</span><br><span class="line">            &#125;</span><br><span class="line">            transformMatrix.mapRect(boundingRect);</span><br><span class="line">            dirty.set((<span class="keyword">int</span>) Math.floor(boundingRect.left),</span><br><span class="line">                    (<span class="keyword">int</span>) Math.floor(boundingRect.top),</span><br><span class="line">                    (<span class="keyword">int</span>) Math.ceil(boundingRect.right),</span><br><span class="line">                    (<span class="keyword">int</span>) Math.ceil(boundingRect.bottom));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawAnimation) &#123;</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ViewRootImpl) &#123;</span><br><span class="line">                    ((ViewRootImpl) parent).mIsAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the parent is dirty opaque or not dirty, mark it dirty with the opaque</span></span><br><span class="line">            <span class="comment">// flag coming from the child that initiated the invalidate</span></span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        view.getSolidColor() == <span class="number">0</span>) &#123;</span><br><span class="line">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Account for transform on current parent</span></span><br><span class="line">                Matrix m = view.getMatrix();</span><br><span class="line">                <span class="keyword">if</span> (!m.isIdentity()) &#123;</span><br><span class="line">                    RectF boundingRect = attachInfo.mTmpTransformRect;</span><br><span class="line">                    boundingRect.set(dirty);</span><br><span class="line">                    m.mapRect(boundingRect);</span><br><span class="line">                    dirty.set((<span class="keyword">int</span>) Math.floor(boundingRect.left),</span><br><span class="line">                            (<span class="keyword">int</span>) Math.floor(boundingRect.top),</span><br><span class="line">                            (<span class="keyword">int</span>) Math.ceil(boundingRect.right),</span><br><span class="line">                            (<span class="keyword">int</span>) Math.ceil(boundingRect.bottom));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，当子View的<code>isOpaque</code>方法返回true时，则设置<code>PFLAG_DIRTY_OPAQUE</code>标志。该方法可以重写，实现自己想要的效果。那默认情况下，是否是Opaque（实心）是怎么判断的，这个答案可以在<code>View.computeOpaqueFlags()</code>中找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpaque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_OPAQUE_MASK) == PFLAG_OPAQUE_MASK &amp;&amp;</span><br><span class="line">                getFinalAlpha() &gt;= <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">computeOpaqueFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Opaque if:</span></span><br><span class="line">    <span class="comment">//   - Has a background</span></span><br><span class="line">    <span class="comment">//   - Background is opaque</span></span><br><span class="line">    <span class="comment">//   - Doesn't have scrollbars or scrollbars overlay</span></span><br><span class="line">    <span class="comment">// 有背景且背景不透明</span></span><br><span class="line">    <span class="keyword">if</span> (mBackground != <span class="keyword">null</span> &amp;&amp; mBackground.getOpacity() == PixelFormat.OPAQUE) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_OPAQUE_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_OPAQUE_BACKGROUND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有scrollbars或者类型为overlay</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags = mViewFlags;</span><br><span class="line">    <span class="keyword">if</span> (((flags &amp; SCROLLBARS_VERTICAL) == <span class="number">0</span> &amp;&amp; (flags &amp; SCROLLBARS_HORIZONTAL) == <span class="number">0</span>) ||</span><br><span class="line">            (flags &amp; SCROLLBARS_STYLE_MASK) == SCROLLBARS_INSIDE_OVERLAY ||</span><br><span class="line">            (flags &amp; SCROLLBARS_STYLE_MASK) == SCROLLBARS_OUTSIDE_OVERLAY) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_OPAQUE_SCROLLBARS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_OPAQUE_SCROLLBARS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View全部满足<code>computeOpaqueFlags</code>中的<strong>三个</strong>条件，<code>isOpaque</code>则返回true。</p><p>通过上面的分析，最终找到了ViewGroup中drawBackground和onDraw的执行条件：子View是非实心的，即<code>isOpaque</code>返回false。这里还有一个前提，就是<strong>子View重绘执行<code>invalidate</code>并且没有硬件加速时</strong>。在第一次遍历时，是没有判断子View是否是实心的，那执行条件又是怎样的？其实刚开始分析draw执行的条件时就有答案了，<strong>只要执行draw就会执行<code>drawBackground</code>和<code>onDraw</code>，因为没有设置标志位，则<code>dirtyOpapue</code>一直为false</strong>。</p><h2 id="draw总结"><a href="#draw总结" class="headerlink" title="draw总结"></a>draw总结</h2><ol><li>View或ViewGroup是否是opaque的三个<strong>充分必要条件</strong>：<ul><li>有背景</li><li>背景不透明</li><li>没有滚动条或者滚动条为overlay</li></ul></li><li>ViewGroup执行draw的<strong>充分不必要条件</strong>：<ul><li><code>setWillNotDraw(false)</code></li><li>设置背景</li></ul></li><li>ViewGroup执行<code>drawBackground</code>和<code>onDraw</code>分两种情况：<ul><li>第一次遍历时，和执行draw的条件一样</li><li>子View重绘调用<code>invalidate</code>时，充分必要条件是子View为透明非实心的</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/post/view-draw/View绘制.png&quot; title=&quot;View绘制流程图&quot;&gt;
&lt;p&gt;View绘制流程基本上是在&lt;code&gt;ViewRootImpl.java&lt;/code&gt;中进行的，上面的流程图是按照第一次加载时的顺序。measure和layout过程没有太多复杂的地方，下面说下draw部分，尤其是在&lt;code&gt;ViewGroup&lt;/code&gt;的draw流程。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://ymlion.com/categories/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="https://ymlion.com/tags/Android/"/>
    
      <category term="源码分析" scheme="https://ymlion.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="View" scheme="https://ymlion.com/tags/View/"/>
    
  </entry>
  
</feed>
